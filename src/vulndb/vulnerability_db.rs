use crate::plugins::plugin_trait::{Finding, Severity};
use crate::vulndb::CveDatabase;
use regex::Regex;
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub enum VulnCheckType {
    OpenPort,
    BannerMatch(String),
    VersionCheck { service: String, pattern: String },
    CustomScript(String),
}

#[derive(Debug, Clone)]
pub struct VulnerabilityRule {
    pub name: String,
    pub description: String,
    pub severity: Severity,
    pub cve_ids: Vec<String>,
    pub ports: Vec<u16>,
    pub service_patterns: Vec<String>,
    pub check_type: VulnCheckType,
    pub references: Vec<String>,
    pub exploitable: bool,
    pub patch_available: bool,
    pub category: String,
}

pub struct VulnerabilityDatabase {
    pub rules: Vec<VulnerabilityRule>,
    pub cve_db: CveDatabase,
    pub service_patterns: HashMap<String, Regex>,
}

impl VulnerabilityDatabase {
    pub fn new() -> Self {
        let mut db = Self {
            rules: Vec::new(),
            cve_db: CveDatabase::new(),
            service_patterns: HashMap::new(),
        };
        db.load_vulnerability_rules();
        db.compile_patterns();
        db
    }

    fn load_vulnerability_rules(&mut self) {
        self.rules.extend(vec![
            // Critical vulnerabilities
            VulnerabilityRule {
                name: "Log4Shell (Log4j RCE)".to_string(),
                description: "Apache Log4j2 Remote Code Execution vulnerability. IMMEDIATE ACTION REQUIRED.".to_string(),
                severity: Severity::Critical,
                cve_ids: vec!["CVE-2021-44228".to_string(), "CVE-2021-45046".to_string()],
                ports: vec![80, 443, 8080, 8443, 9200, 9300],
                service_patterns: vec!["tomcat".to_string(), "jetty".to_string(), "elasticsearch".to_string(), "spring".to_string(), "java".to_string()],
                check_type: VulnCheckType::BannerMatch(r"log4j".to_string()),
                references: vec![
                    "https://nvd.nist.gov/vuln/detail/CVE-2021-44228".to_string(),
                    "https://www.cisa.gov/known-exploited-vulnerabilities-catalog".to_string(),
                ],
                exploitable: true,
                patch_available: true,
                category: "rce".to_string(),
            },

            VulnerabilityRule {
                name: "EternalBlue SMB Vulnerability".to_string(),
                description: "Microsoft SMBv1 Server allows remote attackers to execute arbitrary code (WannaCry vector)".to_string(),
                severity: Severity::Critical,
                cve_ids: vec!["CVE-2017-0144".to_string()],
                ports: vec![445, 139],
                service_patterns: vec!["microsoft-ds".to_string(), "smb".to_string()],
                check_type: VulnCheckType::VersionCheck {
                    service: "smb".to_string(),
                    pattern: r"Windows.*([5-6]\.[0-9])".to_string(),
                },
                references: vec![
                    "https://nvd.nist.gov/vuln/detail/CVE-2017-0144".to_string(),
                    "https://docs.microsoft.com/en-us/security-updates/securitybulletins/2017/ms17-010".to_string(),
                ],
                exploitable: true,
                patch_available: true,
                category: "rce".to_string(),
            },

            // High severity vulnerabilities
            VulnerabilityRule {
                name: "OpenSSH User Enumeration".to_string(),
                description: "OpenSSH allows remote attackers to enumerate users via timing attacks".to_string(),
                severity: Severity::High,
                cve_ids: vec!["CVE-2016-6210".to_string()],
                ports: vec![22],
                service_patterns: vec!["openssh".to_string()],
                check_type: VulnCheckType::VersionCheck {
                    service: "ssh".to_string(),
                    pattern: r"OpenSSH_([5-7]\.[0-9])".to_string(),
                },
                references: vec![
                    "https://nvd.nist.gov/vuln/detail/CVE-2016-6210".to_string(),
                ],
                exploitable: true,
                patch_available: true,
                category: "auth".to_string(),
            },

            VulnerabilityRule {
                name: "Redis Unauthorized Access".to_string(),
                description: "Redis server accessible without authentication - can lead to RCE".to_string(),
                severity: Severity::High,
                cve_ids: vec!["CVE-2022-0543".to_string()],
                ports: vec![6379],
                service_patterns: vec!["redis".to_string()],
                check_type: VulnCheckType::CustomScript("redis_unauth".to_string()),
                references: vec![
                    "https://nvd.nist.gov/vuln/detail/CVE-2022-0543".to_string(),
                    "https://book.hacktricks.xyz/network-services-pentesting/6379-pentesting-redis".to_string(),
                ],
                exploitable: true,
                patch_available: true,
                category: "auth".to_string(),
            },

            // Database exposures
            VulnerabilityRule {
                name: "MySQL Root Remote Access".to_string(),
                description: "MySQL server allows remote root access without proper authentication".to_string(),
                severity: Severity::High,
                cve_ids: vec![],
                ports: vec![3306],
                service_patterns: vec!["mysql".to_string()],
                check_type: VulnCheckType::CustomScript("mysql_root_remote".to_string()),
                references: vec![
                    "https://dev.mysql.com/doc/refman/8.0/en/default-privileges.html".to_string(),
                ],
                exploitable: true,
                patch_available: true,
                category: "database".to_string(),
            },

            VulnerabilityRule {
                name: "PostgreSQL Weak Configuration".to_string(),
                description: "PostgreSQL server may allow unauthorized connections".to_string(),
                severity: Severity::Medium,
                cve_ids: vec![],
                ports: vec![5432],
                service_patterns: vec!["postgresql".to_string()],
                check_type: VulnCheckType::CustomScript("postgres_weak_auth".to_string()),
                references: vec![
                    "https://www.postgresql.org/docs/current/auth-pg-hba-conf.html".to_string(),
                ],
                exploitable: false,
                patch_available: true,
                category: "database".to_string(),
            },

            // Web vulnerabilities
            VulnerabilityRule {
                name: "Apache HTTPd Server Info Disclosure".to_string(),
                description: "Apache HTTP server may expose sensitive information in headers".to_string(),
                severity: Severity::Low,
                cve_ids: vec![],
                ports: vec![80, 443, 8080, 8443],
                service_patterns: vec!["apache".to_string(), "httpd".to_string()],
                check_type: VulnCheckType::BannerMatch(r"Apache/[0-9]\.[0-9]\.[0-9]".to_string()),
                references: vec![
                    "https://httpd.apache.org/docs/2.4/mod/core.html#servertokens".to_string(),
                ],
                exploitable: false,
                patch_available: true,
                category: "info_disclosure".to_string(),
            },

            // FTP vulnerabilities
            VulnerabilityRule {
                name: "FTP Anonymous Login Enabled".to_string(),
                description: "FTP server allows anonymous login - potential data exposure".to_string(),
                severity: Severity::Medium,
                cve_ids: vec![],
                ports: vec![21],
                service_patterns: vec!["ftp".to_string()],
                check_type: VulnCheckType::CustomScript("ftp_anonymous".to_string()),
                references: vec![
                    "https://owasp.org/www-community/vulnerabilities/Insecure_Transport".to_string(),
                ],
                exploitable: true,
                patch_available: true,
                category: "auth".to_string(),
            },

            // Network service exposures
            VulnerabilityRule {
                name: "Telnet Service Active".to_string(),
                description: "Telnet transmits credentials in plaintext - use SSH instead".to_string(),
                severity: Severity::High,
                cve_ids: vec![],
                ports: vec![23],
                service_patterns: vec!["telnet".to_string()],
                check_type: VulnCheckType::OpenPort,
                references: vec![
                    "https://owasp.org/www-community/vulnerabilities/Insecure_Transport".to_string(),
                ],
                exploitable: true,
                patch_available: true,
                category: "plaintext".to_string(),
            },

            VulnerabilityRule {
                name: "SNMP Default Community Strings".to_string(),
                description: "SNMP service may be using default community strings (public/private)".to_string(),
                severity: Severity::Medium,
                cve_ids: vec![],
                ports: vec![161, 162],
                service_patterns: vec!["snmp".to_string()],
                check_type: VulnCheckType::CustomScript("snmp_default_community".to_string()),
                references: vec![
                    "https://owasp.org/www-project-top-ten/2021/A07_2021-Identification_and_Authentication_Failures/".to_string(),
                ],
                exploitable: true,
                patch_available: true,
                category: "auth".to_string(),
            },
        ]);
    }

    fn compile_patterns(&mut self) {
        for rule in &self.rules {
            for pattern in &rule.service_patterns {
                if !self.service_patterns.contains_key(pattern) {
                    if let Ok(regex) = Regex::new(&format!("(?i){}", pattern)) {
                        self.service_patterns.insert(pattern.clone(), regex);
                    }
                }
            }
        }
    }

    pub fn find_vulnerabilities_for_service(
        &self,
        service_name: &str,
        banner: Option<&str>,
    ) -> Vec<&VulnerabilityRule> {
        let mut matches = Vec::new();

        for rule in &self.rules {
            // Check if service pattern matches
            let service_matches = rule.service_patterns.iter().any(|pattern| {
                if let Some(regex) = self.service_patterns.get(pattern) {
                    regex.is_match(service_name) || banner.map_or(false, |b| regex.is_match(b))
                } else {
                    service_name
                        .to_lowercase()
                        .contains(&pattern.to_lowercase())
                }
            });

            if service_matches {
                matches.push(rule);
            }
        }

        matches
    }

    pub fn find_vulnerabilities_for_port(&self, port: u16) -> Vec<&VulnerabilityRule> {
        self.rules
            .iter()
            .filter(|rule| rule.ports.contains(&port))
            .collect()
    }

    pub fn get_vulnerabilities_by_category(&self, category: &str) -> Vec<&VulnerabilityRule> {
        self.rules
            .iter()
            .filter(|rule| rule.category == category)
            .collect()
    }

    pub fn get_critical_vulnerabilities(&self) -> Vec<&VulnerabilityRule> {
        self.rules
            .iter()
            .filter(|rule| matches!(rule.severity, Severity::Critical))
            .collect()
    }

    pub fn get_exploitable_vulnerabilities(&self) -> Vec<&VulnerabilityRule> {
        self.rules.iter().filter(|rule| rule.exploitable).collect()
    }

    pub fn create_finding_from_rule(
        &self,
        rule: &VulnerabilityRule,
        evidence: Vec<String>,
    ) -> Finding {
        let mut metadata = HashMap::new();
        if !rule.cve_ids.is_empty() {
            metadata.insert("cve_ids".to_string(), rule.cve_ids.join(","));
        }
        metadata.insert("category".to_string(), rule.category.clone());
        metadata.insert("exploitable".to_string(), rule.exploitable.to_string());
        metadata.insert(
            "patch_available".to_string(),
            rule.patch_available.to_string(),
        );

        Finding {
            title: rule.name.clone(),
            description: rule.description.clone(),
            severity: rule.severity.clone(),
            confidence: if rule.exploitable { 0.9 } else { 0.7 },
            evidence,
            recommendations: self.get_recommendations_for_rule(rule),
            references: rule.references.clone(),
            metadata,
        }
    }

    fn get_recommendations_for_rule(&self, rule: &VulnerabilityRule) -> Vec<String> {
        match rule.category.as_str() {
            "rce" => vec![
                "Immediately patch the affected service".to_string(),
                "Implement network segmentation".to_string(),
                "Monitor for exploitation attempts".to_string(),
            ],
            "auth" => vec![
                "Implement strong authentication mechanisms".to_string(),
                "Disable default accounts and passwords".to_string(),
                "Enable logging and monitoring".to_string(),
            ],
            "database" => vec![
                "Restrict database access to authorized networks only".to_string(),
                "Use strong authentication and encryption".to_string(),
                "Regular security audits and updates".to_string(),
            ],
            "plaintext" => vec![
                "Replace with encrypted alternatives (SSH, HTTPS, etc.)".to_string(),
                "Implement VPN for remote access".to_string(),
            ],
            _ => vec![
                "Review service configuration".to_string(),
                "Apply security updates".to_string(),
                "Follow security best practices".to_string(),
            ],
        }
    }

    /// Find CVEs for a service using the enhanced CVE database search
    pub fn find_cves_for_service(
        &self,
        service: &str,
        version: Option<&str>,
        cpe: Option<&str>,
        min_cvss: f32,
    ) -> Vec<Finding> {
        use crate::plugins::plugin_trait::Finding;
        use std::collections::HashMap;

        let matches = self
            .cve_db
            .search_vulnerabilities(service, version, cpe, min_cvss);

        matches
            .into_iter()
            .map(|m| {
                let sev = match m.severity {
                    Severity::Critical => "CRITICAL",
                    Severity::High => "HIGH",
                    Severity::Medium => "MEDIUM",
                    Severity::Low => "LOW",
                    Severity::Info => "INFO",
                };
                let severity = if sev == "CRITICAL" {
                    crate::plugins::plugin_trait::Severity::Critical
                } else if sev == "HIGH" {
                    crate::plugins::plugin_trait::Severity::High
                } else if sev == "MEDIUM" {
                    crate::plugins::plugin_trait::Severity::Medium
                } else if sev == "LOW" {
                    crate::plugins::plugin_trait::Severity::Low
                } else {
                    crate::plugins::plugin_trait::Severity::Info
                };

                Finding {
                    title: format!("CVE: {}", m.cve_id),
                    description: m.summary,
                    severity,
                    confidence: m.confidence,
                    evidence: vec![format!("Affected service: {}", m.matched_service)],
                    recommendations: vec!["Apply security updates".to_string()],
                    references: vec![m.reference_url],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("cvss_score".to_string(), m.cvss_score.to_string());
                        meta
                    },
                }
            })
            .collect()
    }
}
