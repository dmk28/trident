//! Authentication vulnerability scanning plugins
//!
//! This module contains specialized scanners for authentication vulnerabilities including:
//! - Default accounts and passwords
//! - Weak password policies
//! - Brute force vulnerabilities
//! - Session management issues

use super::{OwaspCategory, VulnerabilityImpact, VulnerabilityScanner};
use crate::plugins::plugin_trait::{
    Finding, FindingBuilder, Plugin, PluginConfig, PluginPriority, PluginResult, Severity,
};
use crate::scanner::{PortStatus, ScanResult};
use async_trait::async_trait;
use std::collections::HashMap;
use std::net::IpAddr;

/// Default Account Scanner
pub struct DefaultAccountScanner {
    name: String,
    version: String,
    default_accounts: HashMap<u16, Vec<(&'static str, &'static str)>>,
}

impl DefaultAccountScanner {
    pub fn new() -> Self {
        let mut default_accounts = HashMap::new();

        // SSH default accounts
        default_accounts.insert(
            22,
            vec![
                ("root", "root"),
                ("admin", "admin"),
                ("user", "user"),
                ("guest", "guest"),
                ("test", "test"),
            ],
        );

        // Telnet default accounts
        default_accounts.insert(
            23,
            vec![
                ("admin", "admin"),
                ("root", "root"),
                ("cisco", "cisco"),
                ("admin", "password"),
            ],
        );

        // FTP default accounts
        default_accounts.insert(
            21,
            vec![
                ("anonymous", ""),
                ("ftp", "ftp"),
                ("admin", "admin"),
                ("guest", "guest"),
            ],
        );

        // RDP default accounts
        default_accounts.insert(
            3389,
            vec![("Administrator", ""), ("admin", "admin"), ("guest", "")],
        );

        Self {
            name: "Default Account Scanner".to_string(),
            version: "1.0.0".to_string(),
            default_accounts,
        }
    }
}

impl FindingBuilder for DefaultAccountScanner {}

#[async_trait]
impl Plugin for DefaultAccountScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Checks for default accounts and credentials in various services"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::Critical
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
            && self.default_accounts.contains_key(&scan_result.port)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        _scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(accounts) = self.default_accounts.get(&port) {
            let service_name = match port {
                22 => "SSH",
                23 => "Telnet",
                21 => "FTP",
                3389 => "RDP",
                _ => "Unknown",
            };

            findings.push(Finding {
                title: format!("Default Accounts Check Required for {}", service_name),
                description: format!(
                    "{} service on port {} should be checked for default or weak credentials",
                    service_name, port
                ),
                severity: Severity::High,
                confidence: 0.6,
                evidence: vec![
                    format!("Service: {} on port {}", service_name, port),
                    format!(
                        "Common default accounts: {}",
                        accounts
                            .iter()
                            .map(|(u, _)| u.to_string())
                            .collect::<Vec<_>>()
                            .join(", ")
                    ),
                ],
                recommendations: vec![
                    "Disable or remove all default accounts".to_string(),
                    "Enforce strong password policies".to_string(),
                    "Implement account lockout policies".to_string(),
                    "Use multi-factor authentication where possible".to_string(),
                    "Monitor for failed authentication attempts".to_string(),
                ],
                references: vec![
                    OwaspCategory::AuthenticationFailures.reference_url(),
                    "https://cwe.mitre.org/data/definitions/798.html".to_string(),
                ],
                metadata: {
                    let mut meta = HashMap::new();
                    meta.insert(
                        "vulnerability_type".to_string(),
                        "default_accounts".to_string(),
                    );
                    meta.insert("service".to_string(), service_name.to_lowercase());
                    meta.insert("port".to_string(), port.to_string());
                    meta
                },
            });
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for DefaultAccountScanner {
    fn applies_to_service(&self, _service_name: &str, port: u16) -> bool {
        self.default_accounts.contains_key(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "authentication".to_string(),
            "default_credentials".to_string(),
            "access_control".to_string(),
        ]
    }
}

/// Weak Password Scanner
pub struct WeakPasswordScanner {
    name: String,
    version: String,
    weak_password_indicators: Vec<String>,
}

impl WeakPasswordScanner {
    pub fn new() -> Self {
        Self {
            name: "Weak Password Policy Scanner".to_string(),
            version: "1.0.0".to_string(),
            weak_password_indicators: vec![
                "password".to_string(),
                "simple".to_string(),
                "weak".to_string(),
                "basic auth".to_string(),
                "no password".to_string(),
                "blank password".to_string(),
            ],
        }
    }

    fn check_for_weak_auth(&self, banner: &str) -> Option<Finding> {
        let banner_lower = banner.to_lowercase();

        for indicator in &self.weak_password_indicators {
            if banner_lower.contains(indicator) {
                return Some(Finding {
                    title: "Weak Authentication Detected".to_string(),
                    description: "The service may be using weak authentication mechanisms or password policies".to_string(),
                    severity: Severity::High,
                    confidence: 0.7,
                    evidence: vec![
                        format!("Weak authentication indicator found: {}", indicator),
                    ],
                    recommendations: vec![
                        "Implement strong password policies (min 12 characters, complexity requirements)".to_string(),
                        "Use multi-factor authentication".to_string(),
                        "Implement account lockout after failed attempts".to_string(),
                        "Use certificate-based authentication where possible".to_string(),
                        "Regular password rotation policies".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::AuthenticationFailures.reference_url(),
                        "https://pages.nist.gov/800-63-3/sp800-63b.html".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "weak_password_policy".to_string());
                        meta.insert("indicator".to_string(), indicator.clone());
                        meta
                    },
                });
            }
        }

        // Check for Basic Authentication
        if banner_lower.contains("www-authenticate: basic") {
            return Some(Finding {
                title: "Basic Authentication in Use".to_string(),
                description: "The service is using HTTP Basic Authentication which transmits credentials in base64 encoding (easily decoded)".to_string(),
                severity: Severity::Medium,
                confidence: 1.0,
                evidence: vec![
                    "HTTP Basic Authentication header detected".to_string(),
                ],
                recommendations: vec![
                    "Use more secure authentication methods (OAuth, JWT, etc.)".to_string(),
                    "Always use HTTPS with Basic Auth".to_string(),
                    "Consider digest authentication or token-based auth".to_string(),
                ],
                references: vec![
                    "https://datatracker.ietf.org/doc/html/rfc7617".to_string(),
                ],
                metadata: {
                    let mut meta = HashMap::new();
                    meta.insert("vulnerability_type".to_string(), "basic_auth".to_string());
                    meta
                },
            });
        }

        None
    }
}

impl FindingBuilder for WeakPasswordScanner {}

#[async_trait]
impl Plugin for WeakPasswordScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for weak password policies and authentication mechanisms"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            if let Some(finding) = self.check_for_weak_auth(banner) {
                findings.push(finding);
            }
        }

        // Check for services known to have weak default configurations
        match port {
            23 => {
                // Telnet - inherently insecure
                findings.push(Finding {
                    title: "Telnet Service Detected - Plaintext Authentication".to_string(),
                    description: "Telnet transmits all data including passwords in plaintext".to_string(),
                    severity: Severity::Critical,
                    confidence: 1.0,
                    evidence: vec![
                        format!("Telnet service running on port {}", port),
                    ],
                    recommendations: vec![
                        "Disable Telnet immediately".to_string(),
                        "Replace with SSH for secure remote access".to_string(),
                        "If Telnet is required, use VPN or secure tunnel".to_string(),
                    ],
                    references: vec![
                        "https://www.cisa.gov/news-events/alerts/2022/04/20/aa22-110a-russian-state-sponsored-and-criminal-cyber-actors-target".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "plaintext_auth".to_string());
                        meta.insert("service".to_string(), "telnet".to_string());
                        meta
                    },
                });
            }
            21 if scan_result
                .banner
                .as_ref()
                .map(|b| b.contains("anonymous"))
                .unwrap_or(false) =>
            {
                // FTP with anonymous access
                findings.push(Finding {
                    title: "FTP Anonymous Access Enabled".to_string(),
                    description:
                        "FTP server allows anonymous access which may expose sensitive data"
                            .to_string(),
                    severity: Severity::High,
                    confidence: 0.9,
                    evidence: vec!["FTP banner indicates anonymous access".to_string()],
                    recommendations: vec![
                        "Disable anonymous FTP access".to_string(),
                        "Use SFTP or FTPS instead of plain FTP".to_string(),
                        "Implement proper authentication and access controls".to_string(),
                    ],
                    references: vec![
                        "https://owasp.org/www-community/vulnerabilities/Insecure_Transport"
                            .to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert(
                            "vulnerability_type".to_string(),
                            "anonymous_access".to_string(),
                        );
                        meta.insert("service".to_string(), "ftp".to_string());
                        meta
                    },
                });
            }
            _ => {}
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for WeakPasswordScanner {
    fn applies_to_service(&self, _service_name: &str, _port: u16) -> bool {
        true // Can apply to any service
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "authentication".to_string(),
            "weak_password".to_string(),
            "access_control".to_string(),
        ]
    }

    async fn passive_analysis(
        &self,
        banner: Option<&str>,
        _service_info: &HashMap<String, String>,
    ) -> Vec<Finding> {
        let mut findings = Vec::new();

        if let Some(banner) = banner {
            if let Some(finding) = self.check_for_weak_auth(banner) {
                findings.push(finding);
            }
        }

        findings
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_account_scanner() {
        let scanner = DefaultAccountScanner::new();
        assert!(scanner.default_accounts.contains_key(&22));
        assert!(scanner.default_accounts.contains_key(&23));
        assert!(scanner.default_accounts.contains_key(&21));
    }

    #[test]
    fn test_weak_password_indicators() {
        let scanner = WeakPasswordScanner::new();
        assert!(!scanner.weak_password_indicators.is_empty());
        assert!(
            scanner
                .weak_password_indicators
                .contains(&"password".to_string())
        );
    }
}
