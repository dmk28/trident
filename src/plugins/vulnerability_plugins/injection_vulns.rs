//! Injection vulnerability scanning plugins
//!
//! This module contains specialized scanners for injection vulnerabilities including:
//! - Command injection
//! - LDAP injection
//! - XPath injection
//! - NoSQL injection
//! - Template injection
//! - Header injection

use super::{OwaspCategory, VulnerabilityImpact, VulnerabilityPatterns, VulnerabilityScanner};
use crate::plugins::plugin_trait::{
    Finding, FindingBuilder, Plugin, PluginConfig, PluginPriority, PluginResult, Severity,
};
use crate::scanner::{PortStatus, ScanResult};
use async_trait::async_trait;
use regex::Regex;
use std::collections::HashMap;
use std::net::IpAddr;

/// Command Injection Scanner
pub struct CommandInjectionScanner {
    name: String,
    version: String,
    error_patterns: Vec<Regex>,
    test_payloads: Vec<String>,
}

impl CommandInjectionScanner {
    pub fn new() -> Self {
        let patterns = VulnerabilityPatterns::command_injection_patterns();
        let error_patterns = patterns.iter().filter_map(|p| Regex::new(p).ok()).collect();

        Self {
            name: "Command Injection Scanner".to_string(),
            version: "1.0.0".to_string(),
            error_patterns,
            test_payloads: vec![
                "; ls -la".to_string(),
                "| whoami".to_string(),
                "&& cat /etc/passwd".to_string(),
                "`id`".to_string(),
                "$(whoami)".to_string(),
                "; ping -c 1 127.0.0.1".to_string(),
            ],
        }
    }

    fn check_for_command_injection(&self, response: &str) -> Option<Finding> {
        for pattern in &self.error_patterns {
            if pattern.is_match(response) {
                return Some(Finding {
                    title: "Command Injection Vulnerability Detected".to_string(),
                    description: "The application appears to be vulnerable to command injection attacks. System command error messages are being exposed.".to_string(),
                    severity: Severity::Critical,
                    confidence: 0.9,
                    evidence: vec![
                        "Command execution error detected in response".to_string(),
                        format!("Pattern matched: {}", pattern.as_str()),
                    ],
                    recommendations: vec![
                        "Never pass user input directly to system commands".to_string(),
                        "Use parameterized commands or safe APIs".to_string(),
                        "Implement strict input validation and sanitization".to_string(),
                        "Use least privilege for application processes".to_string(),
                        "Consider using a sandbox or container".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::Injection.reference_url(),
                        "https://cwe.mitre.org/data/definitions/77.html".to_string(),
                        "https://owasp.org/www-community/attacks/Command_Injection".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "command_injection".to_string());
                        meta.insert("owasp_category".to_string(), OwaspCategory::Injection.to_string());
                        meta.insert("impact".to_string(), VulnerabilityImpact::RemoteCodeExecution.description().to_string());
                        meta
                    },
                });
            }
        }
        None
    }
}

impl FindingBuilder for CommandInjectionScanner {}

#[async_trait]
impl Plugin for CommandInjectionScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for command injection vulnerabilities"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::Critical
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            if let Some(finding) = self.check_for_command_injection(banner) {
                findings.push(finding);
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for CommandInjectionScanner {
    fn applies_to_service(&self, _service_name: &str, _port: u16) -> bool {
        true // Can apply to any service
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "injection".to_string(),
            "command_injection".to_string(),
            "rce".to_string(),
        ]
    }

    async fn passive_analysis(
        &self,
        banner: Option<&str>,
        _service_info: &HashMap<String, String>,
    ) -> Vec<Finding> {
        let mut findings = Vec::new();

        if let Some(banner) = banner {
            if let Some(finding) = self.check_for_command_injection(banner) {
                findings.push(finding);
            }
        }

        findings
    }
}

/// LDAP Injection Scanner
pub struct LdapInjectionScanner {
    name: String,
    version: String,
    error_patterns: Vec<Regex>,
}

impl LdapInjectionScanner {
    pub fn new() -> Self {
        let patterns = VulnerabilityPatterns::ldap_injection_patterns();
        let error_patterns = patterns.iter().filter_map(|p| Regex::new(p).ok()).collect();

        Self {
            name: "LDAP Injection Scanner".to_string(),
            version: "1.0.0".to_string(),
            error_patterns,
        }
    }

    fn check_for_ldap_injection(&self, response: &str) -> Option<Finding> {
        for pattern in &self.error_patterns {
            if pattern.is_match(response) {
                return Some(Finding {
                    title: "LDAP Injection Vulnerability Detected".to_string(),
                    description: "The application appears to be vulnerable to LDAP injection attacks. LDAP error messages are being exposed.".to_string(),
                    severity: Severity::High,
                    confidence: 0.85,
                    evidence: vec![
                        "LDAP error message detected in response".to_string(),
                        format!("Pattern matched: {}", pattern.as_str()),
                    ],
                    recommendations: vec![
                        "Use parameterized LDAP queries".to_string(),
                        "Escape special LDAP characters in user input".to_string(),
                        "Implement strict input validation".to_string(),
                        "Use least privilege for LDAP connections".to_string(),
                        "Hide LDAP error messages from users".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::Injection.reference_url(),
                        "https://cwe.mitre.org/data/definitions/90.html".to_string(),
                        "https://owasp.org/www-community/attacks/LDAP_Injection".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "ldap_injection".to_string());
                        meta.insert("owasp_category".to_string(), OwaspCategory::Injection.to_string());
                        meta
                    },
                });
            }
        }
        None
    }
}

impl FindingBuilder for LdapInjectionScanner {}

#[async_trait]
impl Plugin for LdapInjectionScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for LDAP injection vulnerabilities"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
            && (scan_result.port == 389  // LDAP
                || scan_result.port == 636  // LDAPS
                || scan_result.port == 3268 // Global Catalog
                || scan_result.port == 3269) // Global Catalog SSL
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            if let Some(finding) = self.check_for_ldap_injection(banner) {
                findings.push(finding);
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for LdapInjectionScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        service_name.to_lowercase().contains("ldap") || vec![389, 636, 3268, 3269].contains(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "injection".to_string(),
            "ldap_injection".to_string(),
            "authentication".to_string(),
        ]
    }
}

/// NoSQL Injection Scanner
pub struct NoSqlInjectionScanner {
    name: String,
    version: String,
    nosql_patterns: Vec<Regex>,
}

impl NoSqlInjectionScanner {
    pub fn new() -> Self {
        let patterns = vec![
            r"MongoError",
            r"MongoDB.*Exception",
            r"CouchDB.*error",
            r"Cassandra.*Exception",
            r"Redis.*Error",
            r"\$where.*function",
            r"\$ne.*null",
            r"\$gt.*''",
            r"\$regex.*\.",
        ];

        let nosql_patterns = patterns.iter().filter_map(|p| Regex::new(p).ok()).collect();

        Self {
            name: "NoSQL Injection Scanner".to_string(),
            version: "1.0.0".to_string(),
            nosql_patterns,
        }
    }

    fn check_for_nosql_injection(&self, response: &str) -> Option<Finding> {
        for pattern in &self.nosql_patterns {
            if pattern.is_match(response) {
                return Some(Finding {
                    title: "NoSQL Injection Vulnerability Detected".to_string(),
                    description: "The application appears to be vulnerable to NoSQL injection attacks. NoSQL database error messages or query operators are being exposed.".to_string(),
                    severity: Severity::High,
                    confidence: 0.8,
                    evidence: vec![
                        "NoSQL pattern detected in response".to_string(),
                        format!("Pattern matched: {}", pattern.as_str()),
                    ],
                    recommendations: vec![
                        "Validate and sanitize all user input".to_string(),
                        "Use parameterized queries where possible".to_string(),
                        "Avoid using JavaScript execution in queries".to_string(),
                        "Implement strict schema validation".to_string(),
                        "Use least privilege for database connections".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::Injection.reference_url(),
                        "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "nosql_injection".to_string());
                        meta.insert("owasp_category".to_string(), OwaspCategory::Injection.to_string());
                        meta
                    },
                });
            }
        }
        None
    }
}

impl FindingBuilder for NoSqlInjectionScanner {}

#[async_trait]
impl Plugin for NoSqlInjectionScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for NoSQL injection vulnerabilities"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
            && (scan_result.port == 27017  // MongoDB
                || scan_result.port == 6379   // Redis
                || scan_result.port == 5984   // CouchDB
                || scan_result.port == 9042   // Cassandra
                || scan_result.port == 8091) // Couchbase
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            if let Some(finding) = self.check_for_nosql_injection(banner) {
                findings.push(finding);
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for NoSqlInjectionScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        let nosql_services = vec!["mongodb", "redis", "couchdb", "cassandra", "couchbase"];
        nosql_services
            .iter()
            .any(|s| service_name.to_lowercase().contains(s))
            || vec![27017, 6379, 5984, 9042, 8091].contains(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "injection".to_string(),
            "nosql_injection".to_string(),
            "database".to_string(),
        ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_command_injection_patterns() {
        let scanner = CommandInjectionScanner::new();
        assert!(!scanner.error_patterns.is_empty());
        assert!(!scanner.test_payloads.is_empty());
    }

    #[test]
    fn test_ldap_injection_scanner() {
        let scanner = LdapInjectionScanner::new();
        assert!(!scanner.error_patterns.is_empty());
    }

    #[test]
    fn test_nosql_injection_patterns() {
        let scanner = NoSqlInjectionScanner::new();
        assert!(!scanner.nosql_patterns.is_empty());
    }
}
