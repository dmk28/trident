//! Network-level vulnerability scanning plugins
//!
//! This module contains specialized scanners for network vulnerabilities including:
//! - Plaintext protocols
//! - Weak cipher suites
//! - SSL/TLS vulnerabilities
//! - Network misconfigurations

use super::{OwaspCategory, VulnerabilityImpact, VulnerabilityScanner};
use crate::plugins::plugin_trait::{
    Finding, FindingBuilder, Plugin, PluginConfig, PluginPriority, PluginResult, Severity,
};
use crate::scanner::{PortStatus, ScanResult};
use async_trait::async_trait;
use std::collections::HashMap;
use std::net::IpAddr;

/// Plaintext Protocol Scanner
pub struct PlaintextProtocolScanner {
    name: String,
    version: String,
    plaintext_ports: HashMap<u16, &'static str>,
}

impl PlaintextProtocolScanner {
    pub fn new() -> Self {
        let mut plaintext_ports = HashMap::new();
        plaintext_ports.insert(21, "FTP");
        plaintext_ports.insert(23, "Telnet");
        plaintext_ports.insert(25, "SMTP");
        plaintext_ports.insert(110, "POP3");
        plaintext_ports.insert(143, "IMAP");
        plaintext_ports.insert(161, "SNMP");
        plaintext_ports.insert(512, "rexec");
        plaintext_ports.insert(513, "rlogin");
        plaintext_ports.insert(514, "rsh");

        Self {
            name: "Plaintext Protocol Scanner".to_string(),
            version: "1.0.0".to_string(),
            plaintext_ports,
        }
    }
}

impl FindingBuilder for PlaintextProtocolScanner {}

#[async_trait]
impl Plugin for PlaintextProtocolScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Detects services using plaintext protocols that transmit data unencrypted"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
            && self.plaintext_ports.contains_key(&scan_result.port)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        _scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(service_name) = self.plaintext_ports.get(&port) {
            findings.push(Finding {
                title: format!("Plaintext Protocol Detected: {}", service_name),
                description: format!(
                    "{} protocol on port {} transmits data including credentials in plaintext, making it vulnerable to eavesdropping and man-in-the-middle attacks",
                    service_name, port
                ),
                severity: if port == 23 { Severity::Critical } else { Severity::High },
                confidence: 1.0,
                evidence: vec![
                    format!("{} service detected on port {}", service_name, port),
                    "Protocol does not use encryption".to_string(),
                ],
                recommendations: vec![
                    format!("Replace {} with its secure alternative", service_name),
                    match port {
                        21 => "Use SFTP or FTPS instead of FTP".to_string(),
                        23 => "Use SSH instead of Telnet".to_string(),
                        25 => "Use SMTP with STARTTLS or SMTPS".to_string(),
                        110 => "Use POP3S instead of POP3".to_string(),
                        143 => "Use IMAPS instead of IMAP".to_string(),
                        161 => "Use SNMPv3 with encryption".to_string(),
                        _ => "Use encrypted alternatives".to_string(),
                    },
                    "Implement VPN or secure tunneling if plaintext protocol is required".to_string(),
                ],
                references: vec![
                    OwaspCategory::CryptographicFailures.reference_url(),
                    "https://owasp.org/www-community/vulnerabilities/Insecure_Transport".to_string(),
                ],
                metadata: {
                    let mut meta = HashMap::new();
                    meta.insert("vulnerability_type".to_string(), "plaintext_protocol".to_string());
                    meta.insert("protocol".to_string(), service_name.to_string());
                    meta.insert("impact".to_string(), VulnerabilityImpact::DataExposure.description().to_string());
                    meta
                },
            });
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for PlaintextProtocolScanner {
    fn applies_to_service(&self, _service_name: &str, port: u16) -> bool {
        self.plaintext_ports.contains_key(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "cryptography".to_string(),
            "plaintext".to_string(),
            "network".to_string(),
        ]
    }
}

/// Weak Cipher Scanner
pub struct WeakCipherScanner {
    name: String,
    version: String,
    weak_ciphers: Vec<&'static str>,
}

impl WeakCipherScanner {
    pub fn new() -> Self {
        Self {
            name: "Weak Cipher Scanner".to_string(),
            version: "1.0.0".to_string(),
            weak_ciphers: vec![
                "RC4", "DES", "3DES", "MD5", "SHA1", "NULL", "EXPORT", "anon", "CBC",
            ],
        }
    }

    fn check_weak_ciphers(&self, banner: &str) -> Option<Finding> {
        let banner_upper = banner.to_uppercase();

        for cipher in &self.weak_ciphers {
            if banner_upper.contains(cipher) {
                return Some(Finding {
                    title: format!("Weak Cipher Suite Detected: {}", cipher),
                    description: format!(
                        "The service appears to be using weak cipher suite containing {}. This cipher is considered cryptographically weak and should not be used.",
                        cipher
                    ),
                    severity: Severity::High,
                    confidence: 0.8,
                    evidence: vec![format!(
                        "Weak cipher {} detected in service response",
                        cipher
                    )],
                    recommendations: vec![
                        "Disable all weak cipher suites".to_string(),
                        "Use only TLS 1.2 or higher".to_string(),
                        "Enable only strong cipher suites (AES-GCM, ChaCha20-Poly1305)".to_string(),
                        "Regularly update TLS/SSL configurations".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::CryptographicFailures.reference_url(),
                        "https://ssl-config.mozilla.org/".to_string(),
                        "https://ciphersuite.info/".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "weak_cipher".to_string());
                        meta.insert("cipher".to_string(), cipher.to_string());
                        meta
                    },
                });
            }
        }
        None
    }
}

impl FindingBuilder for WeakCipherScanner {}

#[async_trait]
impl Plugin for WeakCipherScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Detects weak or outdated cipher suites in SSL/TLS configurations"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
            && (scan_result.port == 443
                || scan_result.port == 8443
                || scan_result.port == 465
                || scan_result.port == 993
                || scan_result.port == 995)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            if let Some(finding) = self.check_weak_ciphers(banner) {
                findings.push(finding);
            }
        }

        // Check for SSL/TLS version issues
        if let Some(banner) = &scan_result.banner {
            if banner.contains("SSLv2") || banner.contains("SSLv3") {
                findings.push(Finding {
                    title: "Obsolete SSL Version Detected".to_string(),
                    description: "The service supports obsolete SSL versions (SSLv2/SSLv3) which have known vulnerabilities".to_string(),
                    severity: Severity::Critical,
                    confidence: 0.95,
                    evidence: vec![
                        "Obsolete SSL version detected in service response".to_string(),
                    ],
                    recommendations: vec![
                        "Disable SSLv2 and SSLv3 immediately".to_string(),
                        "Use only TLS 1.2 or TLS 1.3".to_string(),
                        "Update server configuration to modern standards".to_string(),
                    ],
                    references: vec![
                        "https://www.rfc-editor.org/rfc/rfc7568".to_string(),
                        "https://nvd.nist.gov/vuln/detail/CVE-2014-3566".to_string(), // POODLE
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "obsolete_ssl".to_string());
                        meta
                    },
                });
            }

            if banner.contains("TLSv1.0") || banner.contains("TLSv1.1") {
                findings.push(Finding {
                    title: "Deprecated TLS Version Detected".to_string(),
                    description: "The service supports deprecated TLS versions (1.0/1.1) which should be disabled".to_string(),
                    severity: Severity::Medium,
                    confidence: 0.9,
                    evidence: vec![
                        "Deprecated TLS version detected".to_string(),
                    ],
                    recommendations: vec![
                        "Disable TLS 1.0 and TLS 1.1".to_string(),
                        "Use only TLS 1.2 or TLS 1.3".to_string(),
                    ],
                    references: vec![
                        "https://datatracker.ietf.org/doc/rfc8996/".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "deprecated_tls".to_string());
                        meta
                    },
                });
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for WeakCipherScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        service_name.to_lowercase().contains("ssl")
            || service_name.to_lowercase().contains("tls")
            || service_name.to_lowercase().contains("https")
            || vec![443, 8443, 465, 993, 995].contains(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "cryptography".to_string(),
            "ssl_tls".to_string(),
            "network".to_string(),
        ]
    }

    async fn passive_analysis(
        &self,
        banner: Option<&str>,
        _service_info: &HashMap<String, String>,
    ) -> Vec<Finding> {
        let mut findings = Vec::new();

        if let Some(banner) = banner {
            if let Some(finding) = self.check_weak_ciphers(banner) {
                findings.push(finding);
            }
        }

        findings
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plaintext_protocol_detection() {
        let scanner = PlaintextProtocolScanner::new();
        assert!(scanner.plaintext_ports.contains_key(&23)); // Telnet
        assert!(scanner.plaintext_ports.contains_key(&21)); // FTP
        assert!(!scanner.plaintext_ports.contains_key(&443)); // HTTPS
    }

    #[test]
    fn test_weak_cipher_list() {
        let scanner = WeakCipherScanner::new();
        assert!(scanner.weak_ciphers.contains(&"RC4"));
        assert!(scanner.weak_ciphers.contains(&"DES"));
        assert!(scanner.weak_ciphers.contains(&"MD5"));
    }
}
