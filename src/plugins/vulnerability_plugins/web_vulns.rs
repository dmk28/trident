//! Web application vulnerability scanning plugins
//!
//! This module contains specialized scanners for web vulnerabilities including:
//! - Cross-Site Scripting (XSS)
//! - Directory Traversal
//! - Security Headers
//! - CSRF vulnerabilities
//! - Information disclosure

use super::{OwaspCategory, VulnerabilityImpact, VulnerabilityPatterns, VulnerabilityScanner};
use crate::plugins::plugin_trait::{
    Finding, FindingBuilder, Plugin, PluginConfig, PluginPriority, PluginResult, Severity,
};
use crate::scanner::{PortStatus, ScanResult};
use async_trait::async_trait;
use regex::Regex;
use std::collections::HashMap;
use std::net::IpAddr;

/// XSS (Cross-Site Scripting) Scanner
pub struct XssScanner {
    name: String,
    version: String,
    xss_patterns: Vec<Regex>,
}

impl XssScanner {
    pub fn new() -> Self {
        let patterns = vec![
            r"<script[^>]*>.*?</script>",
            r"javascript:",
            r"on\w+\s*=",
            r"<iframe[^>]*>",
            r"<embed[^>]*>",
            r"<object[^>]*>",
        ];

        let xss_patterns = patterns.iter().filter_map(|p| Regex::new(p).ok()).collect();

        Self {
            name: "XSS Vulnerability Scanner".to_string(),
            version: "1.0.0".to_string(),
            xss_patterns,
        }
    }

    fn check_for_xss_vectors(&self, content: &str) -> Vec<Finding> {
        let mut findings = Vec::new();

        // Check for reflected content that might indicate XSS
        for pattern in &self.xss_patterns {
            if pattern.is_match(content) {
                findings.push(Finding {
                    title: "Potential XSS Vulnerability".to_string(),
                    description: "The application may be vulnerable to Cross-Site Scripting (XSS) attacks. User input appears to be reflected without proper sanitization.".to_string(),
                    severity: Severity::High,
                    confidence: 0.7,
                    evidence: vec![
                        "XSS pattern detected in response".to_string(),
                        format!("Pattern: {}", pattern.as_str()),
                    ],
                    recommendations: vec![
                        "Implement proper input validation and output encoding".to_string(),
                        "Use Content Security Policy (CSP) headers".to_string(),
                        "Sanitize all user input before displaying".to_string(),
                        "Use context-aware encoding (HTML, JavaScript, URL, etc.)".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::Injection.reference_url(),
                        "https://owasp.org/www-community/attacks/xss/".to_string(),
                        "https://cwe.mitre.org/data/definitions/79.html".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "xss".to_string());
                        meta.insert("owasp_category".to_string(), OwaspCategory::Injection.to_string());
                        meta
                    },
                });
                break; // One finding is enough
            }
        }

        findings
    }
}

impl FindingBuilder for XssScanner {}

#[async_trait]
impl Plugin for XssScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for Cross-Site Scripting (XSS) vulnerabilities in web applications"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
            && (scan_result.port == 80
                || scan_result.port == 443
                || scan_result.port == 8080
                || scan_result.port == 8443)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        // Check banner for XSS patterns
        if let Some(banner) = &scan_result.banner {
            findings.extend(self.check_for_xss_vectors(banner));
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for XssScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        service_name.to_lowercase().contains("http") || vec![80, 443, 8080, 8443].contains(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "xss".to_string(),
            "injection".to_string(),
            "web".to_string(),
        ]
    }
}

/// Directory Traversal Scanner
pub struct DirectoryTraversalScanner {
    name: String,
    version: String,
    traversal_patterns: Vec<Regex>,
}

impl DirectoryTraversalScanner {
    pub fn new() -> Self {
        let patterns = VulnerabilityPatterns::path_traversal_patterns();
        let traversal_patterns = patterns.iter().filter_map(|p| Regex::new(p).ok()).collect();

        Self {
            name: "Directory Traversal Scanner".to_string(),
            version: "1.0.0".to_string(),
            traversal_patterns,
        }
    }

    fn check_for_path_traversal(&self, content: &str) -> Option<Finding> {
        for pattern in &self.traversal_patterns {
            if pattern.is_match(content) {
                return Some(Finding {
                    title: "Directory Traversal Vulnerability".to_string(),
                    description: "The application may be vulnerable to directory traversal attacks, potentially exposing sensitive files outside the web root.".to_string(),
                    severity: Severity::High,
                    confidence: 0.85,
                    evidence: vec![
                        "Path traversal pattern detected".to_string(),
                        format!("Pattern matched: {}", pattern.as_str()),
                    ],
                    recommendations: vec![
                        "Validate and sanitize all file path inputs".to_string(),
                        "Use a whitelist of allowed files/directories".to_string(),
                        "Implement proper access controls".to_string(),
                        "Avoid using user input directly in file operations".to_string(),
                        "Use chroot jails or similar sandboxing".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::BrokenAccessControl.reference_url(),
                        "https://owasp.org/www-community/attacks/Path_Traversal".to_string(),
                        "https://cwe.mitre.org/data/definitions/22.html".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "path_traversal".to_string());
                        meta.insert("owasp_category".to_string(), OwaspCategory::BrokenAccessControl.to_string());
                        meta.insert("impact".to_string(), VulnerabilityImpact::DataExposure.description().to_string());
                        meta
                    },
                });
            }
        }
        None
    }
}

impl FindingBuilder for DirectoryTraversalScanner {}

#[async_trait]
impl Plugin for DirectoryTraversalScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for directory traversal vulnerabilities in web applications"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
            && (scan_result.port == 80
                || scan_result.port == 443
                || scan_result.port == 8080
                || scan_result.port == 8443)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            if let Some(finding) = self.check_for_path_traversal(banner) {
                findings.push(finding);
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for DirectoryTraversalScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        service_name.to_lowercase().contains("http") || vec![80, 443, 8080, 8443].contains(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "path_traversal".to_string(),
            "access_control".to_string(),
            "web".to_string(),
        ]
    }
}

/// Security Headers Scanner
pub struct SecurityHeaderScanner {
    name: String,
    version: String,
    required_headers: Vec<(&'static str, Severity)>,
}

impl SecurityHeaderScanner {
    pub fn new() -> Self {
        Self {
            name: "Security Headers Scanner".to_string(),
            version: "1.0.0".to_string(),
            required_headers: vec![
                ("X-Frame-Options", Severity::Medium),
                ("X-Content-Type-Options", Severity::Medium),
                ("X-XSS-Protection", Severity::Low),
                ("Strict-Transport-Security", Severity::High),
                ("Content-Security-Policy", Severity::High),
                ("Referrer-Policy", Severity::Low),
                ("Permissions-Policy", Severity::Medium),
            ],
        }
    }

    fn check_security_headers(&self, headers: &str) -> Vec<Finding> {
        let mut findings = Vec::new();
        let headers_lower = headers.to_lowercase();

        for (header, severity) in &self.required_headers {
            if !headers_lower.contains(&header.to_lowercase()) {
                let finding = Finding {
                    title: format!("Missing Security Header: {}", header),
                    description: format!(
                        "The {} header is missing. This header helps protect against various attacks.",
                        header
                    ),
                    severity: severity.clone(),
                    confidence: 1.0,
                    evidence: vec![format!("Header {} not found in response", header)],
                    recommendations: vec![
                        format!("Add the {} header to all responses", header),
                        self.get_header_recommendation(header),
                    ],
                    references: vec![
                        "https://owasp.org/www-project-secure-headers/".to_string(),
                        "https://securityheaders.com/".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert(
                            "vulnerability_type".to_string(),
                            "missing_security_header".to_string(),
                        );
                        meta.insert("header".to_string(), header.to_string());
                        meta.insert(
                            "owasp_category".to_string(),
                            OwaspCategory::SecurityMisconfiguration.to_string(),
                        );
                        meta
                    },
                };
                findings.push(finding);
            }
        }

        // Check for dangerous headers
        if headers_lower.contains("server:") {
            findings.push(Finding {
                title: "Server Information Disclosure".to_string(),
                description: "The Server header reveals information about the web server software being used.".to_string(),
                severity: Severity::Low,
                confidence: 1.0,
                evidence: vec!["Server header present in response".to_string()],
                recommendations: vec![
                    "Remove or obfuscate the Server header".to_string(),
                    "Configure server to minimize information disclosure".to_string(),
                ],
                references: vec![
                    "https://owasp.org/www-project-secure-headers/".to_string(),
                ],
                metadata: {
                    let mut meta = HashMap::new();
                    meta.insert("vulnerability_type".to_string(), "info_disclosure".to_string());
                    meta.insert("header".to_string(), "Server".to_string());
                    meta
                },
            });
        }

        if headers_lower.contains("x-powered-by:") {
            findings.push(Finding {
                title: "Technology Stack Disclosure".to_string(),
                description:
                    "The X-Powered-By header reveals information about the technology stack."
                        .to_string(),
                severity: Severity::Low,
                confidence: 1.0,
                evidence: vec!["X-Powered-By header present in response".to_string()],
                recommendations: vec![
                    "Remove the X-Powered-By header".to_string(),
                    "Disable technology disclosure in application configuration".to_string(),
                ],
                references: vec!["https://owasp.org/www-project-secure-headers/".to_string()],
                metadata: {
                    let mut meta = HashMap::new();
                    meta.insert(
                        "vulnerability_type".to_string(),
                        "info_disclosure".to_string(),
                    );
                    meta.insert("header".to_string(), "X-Powered-By".to_string());
                    meta
                },
            });
        }

        findings
    }

    fn get_header_recommendation(&self, header: &str) -> String {
        match header {
            "X-Frame-Options" => {
                "Set to 'DENY' or 'SAMEORIGIN' to prevent clickjacking".to_string()
            }
            "X-Content-Type-Options" => {
                "Set to 'nosniff' to prevent MIME type sniffing".to_string()
            }
            "X-XSS-Protection" => "Set to '1; mode=block' to enable XSS filtering".to_string(),
            "Strict-Transport-Security" => {
                "Set to 'max-age=31536000; includeSubDomains' for HTTPS enforcement".to_string()
            }
            "Content-Security-Policy" => {
                "Configure appropriate CSP directives for your application".to_string()
            }
            "Referrer-Policy" => {
                "Set to 'strict-origin-when-cross-origin' or more restrictive".to_string()
            }
            "Permissions-Policy" => {
                "Configure to restrict browser features appropriately".to_string()
            }
            _ => "Configure according to security best practices".to_string(),
        }
    }
}

impl FindingBuilder for SecurityHeaderScanner {}

#[async_trait]
impl Plugin for SecurityHeaderScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Checks for missing or misconfigured security headers in web applications"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::Medium
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
            && (scan_result.port == 80
                || scan_result.port == 443
                || scan_result.port == 8080
                || scan_result.port == 8443)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        // In a real implementation, we would make an HTTP request here
        // For now, check if banner contains HTTP headers
        if let Some(banner) = &scan_result.banner {
            if banner.contains("HTTP/") {
                findings.extend(self.check_security_headers(banner));
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for SecurityHeaderScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        service_name.to_lowercase().contains("http") || vec![80, 443, 8080, 8443].contains(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "security_headers".to_string(),
            "configuration".to_string(),
            "web".to_string(),
        ]
    }

    async fn passive_analysis(
        &self,
        banner: Option<&str>,
        _service_info: &HashMap<String, String>,
    ) -> Vec<Finding> {
        let mut findings = Vec::new();

        if let Some(banner) = banner {
            if banner.contains("HTTP/") {
                findings.extend(self.check_security_headers(banner));
            }
        }

        findings
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_xss_scanner_patterns() {
        let scanner = XssScanner::new();
        assert!(!scanner.xss_patterns.is_empty());
    }

    #[test]
    fn test_security_header_recommendations() {
        let scanner = SecurityHeaderScanner::new();
        let rec = scanner.get_header_recommendation("X-Frame-Options");
        assert!(rec.contains("clickjacking"));
    }

    #[test]
    fn test_directory_traversal_patterns() {
        let scanner = DirectoryTraversalScanner::new();
        assert!(!scanner.traversal_patterns.is_empty());
    }
}
