//! Configuration vulnerability scanning plugins
//!
//! This module contains specialized scanners for configuration vulnerabilities including:
//! - Security misconfigurations
//! - Debug mode exposure
//! - Default configurations
//! - Unnecessary services

use super::{OwaspCategory, VulnerabilityImpact, VulnerabilityScanner};
use crate::plugins::plugin_trait::{
    Finding, FindingBuilder, Plugin, PluginConfig, PluginPriority, PluginResult, Severity,
};
use crate::scanner::{PortStatus, ScanResult};
use async_trait::async_trait;
use std::collections::HashMap;
use std::net::IpAddr;

/// Security Misconfiguration Scanner
pub struct MisconfigurationScanner {
    name: String,
    version: String,
    misconfiguration_patterns: Vec<(&'static str, &'static str)>,
}

impl MisconfigurationScanner {
    pub fn new() -> Self {
        Self {
            name: "Security Misconfiguration Scanner".to_string(),
            version: "1.0.0".to_string(),
            misconfiguration_patterns: vec![
                ("directory listing", "Directory listing enabled"),
                ("autoindex", "Auto-indexing enabled"),
                ("error_reporting", "Verbose error reporting enabled"),
                ("display_errors", "Error display enabled"),
                ("allow_url_include", "Remote file inclusion enabled"),
                ("expose_php", "PHP version exposed"),
                ("server_tokens", "Server tokens exposed"),
                ("trace", "HTTP TRACE method enabled"),
                ("options", "HTTP OPTIONS method enabled"),
            ],
        }
    }

    fn check_misconfigurations(&self, banner: &str) -> Vec<Finding> {
        let mut findings = Vec::new();
        let banner_lower = banner.to_lowercase();

        for (pattern, description) in &self.misconfiguration_patterns {
            if banner_lower.contains(pattern) {
                findings.push(Finding {
                    title: format!("Security Misconfiguration: {}", description),
                    description: format!(
                        "The service appears to have a security misconfiguration: {}. This could expose sensitive information or create security vulnerabilities.",
                        description
                    ),
                    severity: Severity::Medium,
                    confidence: 0.7,
                    evidence: vec![
                        format!("Configuration issue detected: {}", pattern),
                    ],
                    recommendations: vec![
                        "Review and harden service configuration".to_string(),
                        "Follow security best practices for the service".to_string(),
                        "Disable unnecessary features and verbose output".to_string(),
                        "Implement the principle of least functionality".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::SecurityMisconfiguration.reference_url(),
                        "https://cwe.mitre.org/data/definitions/16.html".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "misconfiguration".to_string());
                        meta.insert("pattern".to_string(), pattern.to_string());
                        meta
                    },
                });
            }
        }

        findings
    }
}

impl FindingBuilder for MisconfigurationScanner {}

#[async_trait]
impl Plugin for MisconfigurationScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for common security misconfigurations in services"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::Medium
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            findings.extend(self.check_misconfigurations(banner));
        }

        // Check for unnecessary services on common ports
        let unnecessary_services = vec![
            (135, "RPC Endpoint Mapper"),
            (139, "NetBIOS Session Service"),
            (445, "SMB (if not file server)"),
            (1900, "UPnP"),
            (5353, "mDNS"),
            (8080, "HTTP Proxy/Alternative HTTP"),
            (8888, "Alternative HTTP"),
        ];

        for (service_port, service_name) in unnecessary_services {
            if port == service_port {
                findings.push(Finding {
                    title: format!("Potentially Unnecessary Service: {}", service_name),
                    description: format!(
                        "Port {} ({}) is open. This service may not be necessary and could increase attack surface.",
                        service_port, service_name
                    ),
                    severity: Severity::Low,
                    confidence: 0.5,
                    evidence: vec![
                        format!("Service {} detected on port {}", service_name, service_port),
                    ],
                    recommendations: vec![
                        "Review if this service is necessary".to_string(),
                        "Disable unnecessary services".to_string(),
                        "Implement network segmentation".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::SecurityMisconfiguration.reference_url(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "unnecessary_service".to_string());
                        meta.insert("service".to_string(), service_name.to_string());
                        meta
                    },
                });
                break;
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for MisconfigurationScanner {
    fn applies_to_service(&self, _service_name: &str, _port: u16) -> bool {
        true // Can apply to any service
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "misconfiguration".to_string(),
            "hardening".to_string(),
            "security_config".to_string(),
        ]
    }
}

/// Debug Mode Scanner
pub struct DebugModeScanner {
    name: String,
    version: String,
    debug_indicators: Vec<&'static str>,
}

impl DebugModeScanner {
    pub fn new() -> Self {
        Self {
            name: "Debug Mode Scanner".to_string(),
            version: "1.0.0".to_string(),
            debug_indicators: vec![
                "debug",
                "stacktrace",
                "traceback",
                "exception",
                "error_log",
                "dev_mode",
                "development",
                "staging",
                "test",
                "DEBUG=true",
                "WP_DEBUG",
                "display_errors",
                "error_reporting",
                "xdebug",
                "phpinfo",
                "server-status",
                "server-info",
            ],
        }
    }

    fn check_debug_mode(&self, banner: &str) -> Option<Finding> {
        let banner_lower = banner.to_lowercase();

        for indicator in &self.debug_indicators {
            if banner_lower.contains(indicator) {
                return Some(Finding {
                    title: "Debug Mode or Development Configuration Detected".to_string(),
                    description: format!(
                        "The service appears to be running in debug or development mode. Debug indicator '{}' was detected. This can expose sensitive information and should never be enabled in production.",
                        indicator
                    ),
                    severity: Severity::High,
                    confidence: 0.8,
                    evidence: vec![format!("Debug indicator found: {}", indicator)],
                    recommendations: vec![
                        "Disable debug mode immediately".to_string(),
                        "Remove all development configurations from production".to_string(),
                        "Implement proper logging without exposing details to users".to_string(),
                        "Use environment-specific configurations".to_string(),
                        "Review and remove all debug endpoints".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::SecurityMisconfiguration.reference_url(),
                        "https://cwe.mitre.org/data/definitions/489.html".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "debug_mode".to_string());
                        meta.insert("indicator".to_string(), indicator.to_string());
                        meta.insert(
                            "impact".to_string(),
                            VulnerabilityImpact::InformationDisclosure
                                .description()
                                .to_string(),
                        );
                        meta
                    },
                });
            }
        }
        None
    }
}

impl FindingBuilder for DebugModeScanner {}

#[async_trait]
impl Plugin for DebugModeScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for debug mode and development configurations in production environments"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            if let Some(finding) = self.check_debug_mode(banner) {
                findings.push(finding);
            }
        }

        // Check for debug/development ports
        let debug_ports = vec![
            (9229, "Node.js Inspector"),
            (5005, "Java Debug"),
            (8787, "Ruby Debug"),
            (9000, "PHP XDebug"),
            (4444, "Metasploit"),
            (6666, "Common backdoor"),
            (7777, "Common development"),
            (8888, "Development server"),
            (9999, "Development server"),
        ];

        for (debug_port, description) in debug_ports {
            if port == debug_port {
                findings.push(Finding {
                    title: format!("Debug/Development Port Open: {}", description),
                    description: format!(
                        "Port {} is commonly used for {} and should not be exposed in production",
                        debug_port, description
                    ),
                    severity: Severity::High,
                    confidence: 0.7,
                    evidence: vec![
                        format!("Port {} is open", debug_port),
                    ],
                    recommendations: vec![
                        "Close debug/development ports in production".to_string(),
                        "Use firewall rules to restrict access".to_string(),
                        "Disable debugging features in production".to_string(),
                    ],
                    references: vec![
                        "https://owasp.org/www-project-top-ten/2021/A05_2021-Security_Misconfiguration/".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "debug_port".to_string());
                        meta.insert("port".to_string(), debug_port.to_string());
                        meta
                    },
                });
                break;
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for DebugModeScanner {
    fn applies_to_service(&self, _service_name: &str, _port: u16) -> bool {
        true // Can apply to any service
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "debug".to_string(),
            "development".to_string(),
            "information_disclosure".to_string(),
        ]
    }

    async fn passive_analysis(
        &self,
        banner: Option<&str>,
        _service_info: &HashMap<String, String>,
    ) -> Vec<Finding> {
        let mut findings = Vec::new();

        if let Some(banner) = banner {
            if let Some(finding) = self.check_debug_mode(banner) {
                findings.push(finding);
            }
        }

        findings
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_misconfiguration_patterns() {
        let scanner = MisconfigurationScanner::new();
        assert!(!scanner.misconfiguration_patterns.is_empty());
    }

    #[test]
    fn test_debug_indicators() {
        let scanner = DebugModeScanner::new();
        assert!(scanner.debug_indicators.contains(&"debug"));
        assert!(scanner.debug_indicators.contains(&"stacktrace"));
        assert!(scanner.debug_indicators.contains(&"xdebug"));
    }
}
