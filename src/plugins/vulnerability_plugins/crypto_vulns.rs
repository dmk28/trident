//! Cryptographic vulnerability scanning plugins
//!
//! This module contains specialized scanners for cryptographic vulnerabilities including:
//! - Weak encryption algorithms
//! - Insufficient key lengths
//! - Predictable random number generation
//! - Certificate validation issues

use super::{OwaspCategory, VulnerabilityImpact, VulnerabilityScanner};
use crate::plugins::plugin_trait::{
    Finding, FindingBuilder, Plugin, PluginConfig, PluginPriority, PluginResult, Severity,
};
use crate::scanner::{PortStatus, ScanResult};
use async_trait::async_trait;
use regex::Regex;
use std::collections::HashMap;
use std::net::IpAddr;

/// Weak Encryption Scanner
pub struct WeakEncryptionScanner {
    name: String,
    version: String,
    weak_algorithms: Vec<&'static str>,
    weak_key_sizes: HashMap<&'static str, u32>,
}

impl WeakEncryptionScanner {
    pub fn new() -> Self {
        let mut weak_key_sizes = HashMap::new();
        weak_key_sizes.insert("RSA", 2048); // Less than 2048 is weak
        weak_key_sizes.insert("DSA", 2048);
        weak_key_sizes.insert("DH", 2048);
        weak_key_sizes.insert("ECDSA", 224); // Less than 224 is weak
        weak_key_sizes.insert("AES", 128); // Less than 128 is weak

        Self {
            name: "Weak Encryption Scanner".to_string(),
            version: "1.0.0".to_string(),
            weak_algorithms: vec![
                "DES", "RC4", "RC2", "MD5", "SHA1", "MD4", "MD2", "NULL", "EXPORT", "anon", "ADH",
                "AECDH",
            ],
            weak_key_sizes,
        }
    }

    fn check_weak_crypto(&self, banner: &str) -> Vec<Finding> {
        let mut findings = Vec::new();
        let banner_upper = banner.to_uppercase();

        // Check for weak algorithms
        for algo in &self.weak_algorithms {
            if banner_upper.contains(algo) {
                findings.push(Finding {
                    title: format!("Weak Encryption Algorithm: {}", algo),
                    description: format!(
                        "The service is using {} which is a cryptographically weak or broken algorithm",
                        algo
                    ),
                    severity: if algo == &"DES" || algo == &"MD5" || algo == &"RC4" {
                        Severity::Critical
                    } else {
                        Severity::High
                    },
                    confidence: 0.85,
                    evidence: vec![format!("Weak algorithm {} detected", algo)],
                    recommendations: vec![
                        "Replace weak encryption algorithms with strong ones".to_string(),
                        "Use AES-256, RSA-2048+ or equivalent".to_string(),
                        "For hashing, use SHA-256 or stronger".to_string(),
                        "Update cryptographic libraries".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::CryptographicFailures.reference_url(),
                        "https://www.keylength.com/".to_string(),
                        "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf"
                            .to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "weak_crypto".to_string());
                        meta.insert("algorithm".to_string(), algo.to_string());
                        meta
                    },
                });
            }
        }

        // Check for weak key sizes (simplified check)
        for (algo_name, min_size) in &self.weak_key_sizes {
            // Look for patterns like "RSA-1024" or "RSA 1024"
            let pattern = format!("{}[- ]\\d+", algo_name);
            if let Ok(re) = regex::Regex::new(&pattern) {
                if let Some(capture) = re.find(&banner_upper) {
                    let matched = capture.as_str();
                    if let Some(size_str) = matched.split(&['-', ' '][..]).nth(1) {
                        if let Ok(size) = size_str.parse::<u32>() {
                            if size < *min_size {
                                findings.push(Finding {
                                    title: format!("Weak Key Size: {} {}-bit", algo_name, size),
                                    description: format!(
                                        "{} is using a {}-bit key which is below the recommended minimum of {} bits",
                                        algo_name, size, min_size
                                    ),
                                    severity: Severity::High,
                                    confidence: 0.9,
                                    evidence: vec![format!("{} {}-bit key detected", algo_name, size)],
                                    recommendations: vec![
                                        format!("Use at least {}-bit keys for {}", min_size, algo_name),
                                        "Generate new keys with appropriate length".to_string(),
                                        "Update cryptographic configurations".to_string(),
                                    ],
                                    references: vec![
                                        "https://www.keylength.com/".to_string(),
                                        "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf".to_string(),
                                    ],
                                    metadata: {
                                        let mut meta = HashMap::new();
                                        meta.insert("vulnerability_type".to_string(), "weak_key_size".to_string());
                                        meta.insert("algorithm".to_string(), algo_name.to_string());
                                        meta.insert("key_size".to_string(), size.to_string());
                                        meta
                                    },
                                });
                            }
                        }
                    }
                }
            }
        }

        findings
    }
}

impl FindingBuilder for WeakEncryptionScanner {}

#[async_trait]
impl Plugin for WeakEncryptionScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for weak encryption algorithms and insufficient key lengths"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            findings.extend(self.check_weak_crypto(banner));
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for WeakEncryptionScanner {
    fn applies_to_service(&self, _service_name: &str, _port: u16) -> bool {
        true // Can apply to any service using encryption
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "cryptography".to_string(),
            "weak_encryption".to_string(),
            "key_management".to_string(),
        ]
    }

    async fn passive_analysis(
        &self,
        banner: Option<&str>,
        _service_info: &HashMap<String, String>,
    ) -> Vec<Finding> {
        let mut findings = Vec::new();

        if let Some(banner) = banner {
            findings.extend(self.check_weak_crypto(banner));
        }

        findings
    }
}

/// Certificate Validation Scanner
pub struct CertificateScanner {
    name: String,
    version: String,
    cert_issues: Vec<&'static str>,
}

impl CertificateScanner {
    pub fn new() -> Self {
        Self {
            name: "Certificate Validation Scanner".to_string(),
            version: "1.0.0".to_string(),
            cert_issues: vec![
                "self-signed",
                "expired",
                "untrusted",
                "invalid",
                "mismatch",
                "revoked",
                "weak signature",
            ],
        }
    }

    fn check_certificate_issues(&self, banner: &str) -> Vec<Finding> {
        let mut findings = Vec::new();
        let banner_lower = banner.to_lowercase();

        for issue in &self.cert_issues {
            if banner_lower.contains(issue) {
                let severity = match *issue {
                    "expired" | "revoked" => Severity::High,
                    "self-signed" | "untrusted" => Severity::Medium,
                    _ => Severity::Low,
                };

                findings.push(Finding {
                    title: format!("Certificate Issue: {}", issue.to_uppercase()),
                    description: format!(
                        "The service certificate has the following issue: {}",
                        issue
                    ),
                    severity,
                    confidence: 0.8,
                    evidence: vec![format!("Certificate issue detected: {}", issue)],
                    recommendations: vec![
                        "Obtain a valid certificate from a trusted CA".to_string(),
                        "Ensure certificates are not expired".to_string(),
                        "Implement proper certificate validation".to_string(),
                        "Use certificate pinning for critical services".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::CryptographicFailures.reference_url(),
                        "https://www.ssl.com/guide/ssl-best-practices/".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert(
                            "vulnerability_type".to_string(),
                            "certificate_issue".to_string(),
                        );
                        meta.insert("issue".to_string(), issue.to_string());
                        meta
                    },
                });
            }
        }

        findings
    }
}

impl FindingBuilder for CertificateScanner {}

#[async_trait]
impl Plugin for CertificateScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for SSL/TLS certificate validation issues"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::Medium
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
            && (scan_result.port == 443
                || scan_result.port == 8443
                || scan_result.port == 465
                || scan_result.port == 993
                || scan_result.port == 995)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        if let Some(banner) = &scan_result.banner {
            findings.extend(self.check_certificate_issues(banner));
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for CertificateScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        service_name.to_lowercase().contains("ssl")
            || service_name.to_lowercase().contains("tls")
            || service_name.to_lowercase().contains("https")
            || vec![443, 8443, 465, 993, 995].contains(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "certificate".to_string(),
            "ssl_tls".to_string(),
            "cryptography".to_string(),
        ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_weak_encryption_algorithms() {
        let scanner = WeakEncryptionScanner::new();
        assert!(scanner.weak_algorithms.contains(&"DES"));
        assert!(scanner.weak_algorithms.contains(&"MD5"));
        assert!(scanner.weak_algorithms.contains(&"RC4"));
    }

    #[test]
    fn test_weak_key_sizes() {
        let scanner = WeakEncryptionScanner::new();
        assert_eq!(*scanner.weak_key_sizes.get("RSA").unwrap(), 2048);
        assert_eq!(*scanner.weak_key_sizes.get("AES").unwrap(), 128);
    }

    #[test]
    fn test_certificate_issues() {
        let scanner = CertificateScanner::new();
        assert!(scanner.cert_issues.contains(&"self-signed"));
        assert!(scanner.cert_issues.contains(&"expired"));
    }
}
