//! Vulnerability-focused security scanning plugins
//!
//! This module contains specialized plugins that focus on identifying
//! security vulnerabilities rather than just service detection.

pub mod auth_vulns;
pub mod config_vulns;
pub mod crypto_vulns;
pub mod database_vulns;
pub mod injection_vulns;
pub mod network_vulns;
pub mod web_vulns;

use crate::plugins::plugin_trait::{
    Finding, FindingBuilder, Plugin, PluginConfig, PluginPriority, PluginResult, Severity,
};
use crate::scanner::ScanResult;
use async_trait::async_trait;
use std::collections::HashMap;
use std::net::IpAddr;

/// Base trait for vulnerability scanning plugins
#[async_trait]
pub trait VulnerabilityScanner: Send + Sync {
    /// Check if this scanner applies to the given service
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool;

    /// Get the vulnerability categories this scanner checks for
    fn vulnerability_categories(&self) -> Vec<String>;

    /// Perform active vulnerability scanning (if supported)
    async fn active_scan(
        &self,
        target: IpAddr,
        port: u16,
        service_info: &HashMap<String, String>,
    ) -> Vec<Finding> {
        // Default: no active scanning
        Vec::new()
    }

    /// Perform passive vulnerability analysis based on collected data
    async fn passive_analysis(
        &self,
        banner: Option<&str>,
        service_info: &HashMap<String, String>,
    ) -> Vec<Finding> {
        // Default: no passive analysis
        Vec::new()
    }

    /// Check for known CVEs based on service version
    fn check_cves(&self, service: &str, version: Option<&str>) -> Vec<Finding> {
        let mut findings = Vec::new();

        // This would integrate with CVE database
        if let Some(ver) = version {
            // Example CVE check logic
            findings.push(Finding {
                title: format!("Version {} of {} detected", ver, service),
                description: "Service version information exposed - check for known CVEs"
                    .to_string(),
                severity: Severity::Info,
                confidence: 0.9,
                evidence: vec![format!("Version: {}", ver)],
                recommendations: vec![
                    "Review CVE database for this version".to_string(),
                    "Consider hiding version information".to_string(),
                ],
                references: vec![],
                metadata: HashMap::new(),
            });
        }

        findings
    }
}

/// Common vulnerability patterns used across different scanners
pub struct VulnerabilityPatterns;

impl VulnerabilityPatterns {
    /// SQL Injection patterns
    pub fn sql_injection_patterns() -> Vec<&'static str> {
        vec![
            "SQL syntax.*MySQL",
            "Warning.*mysql_.*",
            "valid MySQL result",
            "MySqlClient\\.",
            "PostgreSQL.*ERROR",
            "Warning.*pg_.*",
            "valid PostgreSQL result",
            "Npgsql\\.",
            "Driver.*SQL Server",
            "OLE DB.*SQL Server",
            "SQLServer JDBC Driver",
            "Oracle.*Driver",
            "Oracle.*ORA-[0-9]+",
            "Oracle.*TNS:.*",
            "Microsoft Access Driver",
            "JET Database Engine",
            "Access Database Engine",
            "SQLite.*Warning",
            "sqlite3.OperationalError",
            "SQLite.*no such table",
        ]
    }

    /// Command injection patterns
    pub fn command_injection_patterns() -> Vec<&'static str> {
        vec![
            "sh: .*: command not found",
            "bash: .*: command not found",
            "cmd\\.exe.*not recognized",
            "Cannot execute.*Permission denied",
            "exec\\(\\) has been disabled",
            "system\\(\\) has been disabled",
            "\\[an error occurred while processing this directive\\]",
        ]
    }

    /// Path traversal patterns
    pub fn path_traversal_patterns() -> Vec<&'static str> {
        vec![
            "root:.*:0:0:",
            "daemon:.*:1:1:",
            "\\[boot loader\\]",
            "\\[operating systems\\]",
            "\\[drivers\\]",
            "Failed opening.*for inclusion",
            "Warning.*include\\(",
            "Warning.*require\\(",
        ]
    }

    /// Information disclosure patterns
    pub fn info_disclosure_patterns() -> Vec<&'static str> {
        vec![
            "Index of /",
            "Parent Directory",
            "Directory listing for",
            "Volume Serial Number",
            "\\[To Parent Directory\\]",
            "Apache.*Server at.*Port",
            "Microsoft-IIS.*Server",
            "nginx/[0-9\\.]+",
            "PHP Version",
            "ASP\\.NET Version",
            "Tomcat.*Version",
        ]
    }

    /// Authentication bypass patterns
    pub fn auth_bypass_patterns() -> Vec<&'static str> {
        vec![
            "admin.*logged in",
            "Welcome.*Administrator",
            "Access Granted",
            "Authentication Successful",
            "Session.*created",
            "Token.*generated",
        ]
    }

    /// XXE (XML External Entity) patterns
    pub fn xxe_patterns() -> Vec<&'static str> {
        vec![
            "<!ENTITY.*SYSTEM",
            "<!DOCTYPE.*\\[.*<!ENTITY",
            "SAXParseException",
            "XMLParser.*Error",
            "DOMDocument::loadXML\\(\\)",
            "simplexml_load_string\\(\\)",
            "LIBXML_NOENT",
        ]
    }

    /// LDAP injection patterns
    pub fn ldap_injection_patterns() -> Vec<&'static str> {
        vec![
            "javax\\.naming\\.NameNotFoundException",
            "LDAPException",
            "com\\.sun\\.jndi\\.ldap",
            "Invalid DN syntax",
            "Protocol error occurred",
            "Size limit exceeded",
            "An inappropriate matching occurred",
            "A constraint violation occurred",
        ]
    }

    /// XPath injection patterns
    pub fn xpath_injection_patterns() -> Vec<&'static str> {
        vec![
            "XPathException",
            "MS\\.Internal\\.Xml\\.",
            "Unknown error in XPath",
            "SimpleXMLElement::xpath\\(\\)",
            "DOMXPath::evaluate\\(\\)",
            "xmlXPathEval\\(\\)",
            "Invalid XPath expression",
        ]
    }
}

/// Helper to categorize vulnerabilities by impact
#[derive(Debug, Clone, PartialEq)]
pub enum VulnerabilityImpact {
    RemoteCodeExecution,
    PrivilegeEscalation,
    DataExposure,
    DenialOfService,
    AuthenticationBypass,
    InformationDisclosure,
    IntegrityViolation,
}

impl VulnerabilityImpact {
    pub fn to_severity(&self) -> Severity {
        match self {
            VulnerabilityImpact::RemoteCodeExecution => Severity::Critical,
            VulnerabilityImpact::PrivilegeEscalation => Severity::Critical,
            VulnerabilityImpact::AuthenticationBypass => Severity::High,
            VulnerabilityImpact::DataExposure => Severity::High,
            VulnerabilityImpact::IntegrityViolation => Severity::High,
            VulnerabilityImpact::DenialOfService => Severity::Medium,
            VulnerabilityImpact::InformationDisclosure => Severity::Low,
        }
    }

    pub fn description(&self) -> &str {
        match self {
            VulnerabilityImpact::RemoteCodeExecution => {
                "Allows attackers to execute arbitrary code on the target system"
            }
            VulnerabilityImpact::PrivilegeEscalation => {
                "Allows attackers to gain elevated privileges on the system"
            }
            VulnerabilityImpact::AuthenticationBypass => {
                "Allows attackers to bypass authentication mechanisms"
            }
            VulnerabilityImpact::DataExposure => {
                "Sensitive data may be exposed to unauthorized parties"
            }
            VulnerabilityImpact::IntegrityViolation => "Data integrity may be compromised",
            VulnerabilityImpact::DenialOfService => "Service availability may be impacted",
            VulnerabilityImpact::InformationDisclosure => {
                "System information may be disclosed to attackers"
            }
        }
    }
}

/// Common OWASP Top 10 vulnerability categories
#[derive(Debug, Clone)]
pub enum OwaspCategory {
    BrokenAccessControl,       // A01:2021
    CryptographicFailures,     // A02:2021
    Injection,                 // A03:2021
    InsecureDesign,            // A04:2021
    SecurityMisconfiguration,  // A05:2021
    VulnerableComponents,      // A06:2021
    AuthenticationFailures,    // A07:2021
    DataIntegrityFailures,     // A08:2021
    LoggingMonitoringFailures, // A09:2021
    ServerSideRequestForgery,  // A10:2021
}

impl OwaspCategory {
    pub fn to_string(&self) -> String {
        match self {
            OwaspCategory::BrokenAccessControl => "A01:2021 - Broken Access Control".to_string(),
            OwaspCategory::CryptographicFailures => "A02:2021 - Cryptographic Failures".to_string(),
            OwaspCategory::Injection => "A03:2021 - Injection".to_string(),
            OwaspCategory::InsecureDesign => "A04:2021 - Insecure Design".to_string(),
            OwaspCategory::SecurityMisconfiguration => {
                "A05:2021 - Security Misconfiguration".to_string()
            }
            OwaspCategory::VulnerableComponents => {
                "A06:2021 - Vulnerable and Outdated Components".to_string()
            }
            OwaspCategory::AuthenticationFailures => {
                "A07:2021 - Identification and Authentication Failures".to_string()
            }
            OwaspCategory::DataIntegrityFailures => {
                "A08:2021 - Software and Data Integrity Failures".to_string()
            }
            OwaspCategory::LoggingMonitoringFailures => {
                "A09:2021 - Security Logging and Monitoring Failures".to_string()
            }
            OwaspCategory::ServerSideRequestForgery => {
                "A10:2021 - Server-Side Request Forgery".to_string()
            }
        }
    }

    pub fn reference_url(&self) -> String {
        match self {
            OwaspCategory::BrokenAccessControl => {
                "https://owasp.org/Top10/A01_2021-Broken_Access_Control/".to_string()
            }
            OwaspCategory::CryptographicFailures => {
                "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/".to_string()
            }
            OwaspCategory::Injection => "https://owasp.org/Top10/A03_2021-Injection/".to_string(),
            OwaspCategory::InsecureDesign => {
                "https://owasp.org/Top10/A04_2021-Insecure_Design/".to_string()
            }
            OwaspCategory::SecurityMisconfiguration => {
                "https://owasp.org/Top10/A05_2021-Security_Misconfiguration/".to_string()
            }
            OwaspCategory::VulnerableComponents => {
                "https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/".to_string()
            }
            OwaspCategory::AuthenticationFailures => {
                "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"
                    .to_string()
            }
            OwaspCategory::DataIntegrityFailures => {
                "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/".to_string()
            }
            OwaspCategory::LoggingMonitoringFailures => {
                "https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/"
                    .to_string()
            }
            OwaspCategory::ServerSideRequestForgery => {
                "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery/".to_string()
            }
        }
    }
}

/// Registry of all vulnerability scanning plugins
pub struct VulnerabilityPluginRegistry {
    plugins: Vec<Box<dyn Plugin>>,
}

impl VulnerabilityPluginRegistry {
    pub fn new() -> Self {
        let mut registry = Self {
            plugins: Vec::new(),
        };
        registry.register_default_plugins();
        registry
    }

    fn register_default_plugins(&mut self) {
        // For now, comment these out until we fix the trait compatibility
        // We'll need to restructure how these plugins work
        // TODO: Fix vulnerability scanner plugin registration
    }

    pub fn register_plugin(&mut self, plugin: Box<dyn Plugin>) {
        self.plugins.push(plugin);
    }

    pub fn get_plugins_for_service(&self, _service: &str, _port: u16) -> Vec<&Box<dyn Plugin>> {
        // For now, return all plugins
        self.plugins.iter().collect()
    }

    pub fn get_all_plugins(&self) -> &Vec<Box<dyn Plugin>> {
        &self.plugins
    }
}

/// Test helper for vulnerability plugins
#[cfg(test)]
pub mod test_helpers {
    use super::*;

    pub fn create_test_finding(title: &str, severity: Severity) -> Finding {
        Finding {
            title: title.to_string(),
            description: "Test finding".to_string(),
            severity,
            confidence: 1.0,
            evidence: vec!["Test evidence".to_string()],
            recommendations: vec!["Test recommendation".to_string()],
            references: vec![],
            metadata: HashMap::new(),
        }
    }

    pub fn create_test_service_info() -> HashMap<String, String> {
        let mut info = HashMap::new();
        info.insert("service".to_string(), "test_service".to_string());
        info.insert("version".to_string(), "1.0.0".to_string());
        info.insert("port".to_string(), "8080".to_string());
        info
    }
}
