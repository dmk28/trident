//! Database-specific vulnerability scanning plugins
//!
//! This module contains specialized scanners for database vulnerabilities including:
//! - SQL injection vulnerabilities
//! - Weak authentication mechanisms
//! - Default credentials
//! - Exposed database interfaces
//! - Privilege escalation vectors

use super::{OwaspCategory, VulnerabilityImpact, VulnerabilityPatterns, VulnerabilityScanner};
use crate::plugins::plugin_trait::{
    Finding, FindingBuilder, Plugin, PluginConfig, PluginPriority, PluginResult, Severity,
};
use crate::scanner::{PortStatus, ScanResult};
use async_trait::async_trait;
use regex::Regex;
use std::collections::HashMap;
use std::net::IpAddr;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::time::{Duration, timeout};

/// SQL Injection vulnerability scanner
pub struct SqlInjectionScanner {
    name: String,
    version: String,
    test_payloads: Vec<String>,
    error_patterns: Vec<Regex>,
}

impl SqlInjectionScanner {
    pub fn new() -> Self {
        let patterns = VulnerabilityPatterns::sql_injection_patterns();
        let error_patterns = patterns.iter().filter_map(|p| Regex::new(p).ok()).collect();

        Self {
            name: "SQL Injection Scanner".to_string(),
            version: "1.0.0".to_string(),
            test_payloads: vec![
                "' OR '1'='1".to_string(),
                "\" OR \"1\"=\"1".to_string(),
                "' OR 1=1--".to_string(),
                "admin' --".to_string(),
                "' UNION SELECT NULL--".to_string(),
                "1' AND 1=CONVERT(int, @@version)--".to_string(),
            ],
            error_patterns,
        }
    }

    fn check_for_sql_errors(&self, response: &str) -> Option<Finding> {
        for pattern in &self.error_patterns {
            if pattern.is_match(response) {
                return Some(Finding {
                    title: "SQL Injection Vulnerability Detected".to_string(),
                    description: "The application appears to be vulnerable to SQL injection attacks. Database error messages are being exposed.".to_string(),
                    severity: Severity::Critical,
                    confidence: 0.95,
                    evidence: vec![
                        "SQL error message detected in response".to_string(),
                        format!("Pattern matched: {}", pattern.as_str()),
                    ],
                    recommendations: vec![
                        "Use parameterized queries or prepared statements".to_string(),
                        "Implement proper input validation and sanitization".to_string(),
                        "Apply the principle of least privilege to database accounts".to_string(),
                        "Hide database error messages from users".to_string(),
                    ],
                    references: vec![
                        OwaspCategory::Injection.reference_url(),
                        "https://cwe.mitre.org/data/definitions/89.html".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert("vulnerability_type".to_string(), "sql_injection".to_string());
                        meta.insert("owasp_category".to_string(), OwaspCategory::Injection.to_string());
                        meta.insert("impact".to_string(), VulnerabilityImpact::RemoteCodeExecution.description().to_string());
                        meta
                    },
                });
            }
        }
        None
    }
}

impl FindingBuilder for SqlInjectionScanner {}

#[async_trait]
impl Plugin for SqlInjectionScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for SQL injection vulnerabilities in database services"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::Critical
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        // Only run on database ports or web services that might have SQL backends
        let database_ports = vec![3306, 5432, 1433, 1521, 27017, 6379];
        let web_ports = vec![80, 443, 8080, 8443];

        if !database_ports.contains(&port) && !web_ports.contains(&port) {
            return PluginResult {
                plugin_name: self.name().to_string(),
                target_ip: target,
                target_port: port,
                execution_time: start_time.elapsed(),
                success: false,
                error_message: Some("Not a relevant port for SQL injection testing".to_string()),
                findings,
                raw_data: None,
            };
        }

        // Check if service has any SQL error patterns in banner
        if let Some(banner) = &scan_result.banner {
            if let Some(finding) = self.check_for_sql_errors(banner) {
                findings.push(finding);
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for SqlInjectionScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        let db_services = vec!["mysql", "postgresql", "mssql", "oracle", "mongodb", "redis"];
        let web_services = vec!["http", "https"];

        db_services
            .iter()
            .any(|s| service_name.to_lowercase().contains(s))
            || web_services
                .iter()
                .any(|s| service_name.to_lowercase().contains(s))
            || vec![3306, 5432, 1433, 1521, 80, 443, 8080].contains(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "injection".to_string(),
            "sql_injection".to_string(),
            "database".to_string(),
        ]
    }

    async fn passive_analysis(
        &self,
        banner: Option<&str>,
        _service_info: &HashMap<String, String>,
    ) -> Vec<Finding> {
        let mut findings = Vec::new();

        if let Some(banner) = banner {
            if let Some(finding) = self.check_for_sql_errors(banner) {
                findings.push(finding);
            }
        }

        findings
    }
}

/// Weak Authentication Scanner for databases
pub struct WeakAuthScanner {
    name: String,
    version: String,
}

impl WeakAuthScanner {
    pub fn new() -> Self {
        Self {
            name: "Database Weak Authentication Scanner".to_string(),
            version: "1.0.0".to_string(),
        }
    }

    async fn check_mysql_auth(&self, ip: IpAddr, port: u16) -> Option<Finding> {
        // Try to connect to MySQL and check authentication method
        match timeout(Duration::from_secs(5), TcpStream::connect((ip, port))).await {
            Ok(Ok(mut stream)) => {
                let mut buffer = [0u8; 1024];
                if let Ok(Ok(n)) = timeout(Duration::from_secs(2), stream.read(&mut buffer)).await {
                    let response = String::from_utf8_lossy(&buffer[..n]);

                    // Check for anonymous access indicators
                    if response.contains("mysql_native_password")
                        && !response.contains("caching_sha2_password")
                    {
                        return Some(Finding {
                            title: "MySQL Using Weak Authentication Plugin".to_string(),
                            description: "MySQL server is using mysql_native_password which is less secure than caching_sha2_password".to_string(),
                            severity: Severity::Medium,
                            confidence: 0.8,
                            evidence: vec![
                                "MySQL native password authentication detected".to_string(),
                            ],
                            recommendations: vec![
                                "Upgrade to caching_sha2_password authentication plugin".to_string(),
                                "Use SSL/TLS for all database connections".to_string(),
                                "Implement strong password policies".to_string(),
                            ],
                            references: vec![
                                "https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html".to_string(),
                            ],
                            metadata: {
                                let mut meta = HashMap::new();
                                meta.insert("vulnerability_type".to_string(), "weak_auth".to_string());
                                meta.insert("service".to_string(), "mysql".to_string());
                                meta
                            },
                        });
                    }
                }
            }
            _ => {}
        }
        None
    }

    async fn check_postgres_auth(&self, ip: IpAddr, port: u16) -> Option<Finding> {
        // Try to connect to PostgreSQL and check for trust authentication
        match timeout(Duration::from_secs(5), TcpStream::connect((ip, port))).await {
            Ok(Ok(mut stream)) => {
                // Send a startup message
                let startup_msg = b"\x00\x00\x00\x08\x04\xd2\x16\x2f";
                let _ = stream.write_all(startup_msg).await;

                let mut buffer = [0u8; 1024];
                if let Ok(Ok(n)) = timeout(Duration::from_secs(2), stream.read(&mut buffer)).await {
                    let response = &buffer[..n];

                    // Check for authentication type in response
                    // 'R' (0x52) indicates authentication request
                    if response.len() > 0 && response[0] == 0x52 {
                        // Check the authentication type
                        if response.len() > 8 {
                            let auth_type = i32::from_be_bytes([
                                response[5],
                                response[6],
                                response[7],
                                response[8],
                            ]);

                            match auth_type {
                                0 => {
                                    // Trust authentication
                                    return Some(Finding {
                                        title: "PostgreSQL Trust Authentication Enabled".to_string(),
                                        description: "PostgreSQL is configured with trust authentication, allowing connections without password verification".to_string(),
                                        severity: Severity::Critical,
                                        confidence: 0.95,
                                        evidence: vec![
                                            "PostgreSQL responded with trust authentication (type 0)".to_string(),
                                        ],
                                        recommendations: vec![
                                            "Change authentication method in pg_hba.conf".to_string(),
                                            "Use scram-sha-256 or md5 authentication".to_string(),
                                            "Restrict network access to database".to_string(),
                                        ],
                                        references: vec![
                                            "https://www.postgresql.org/docs/current/auth-trust.html".to_string(),
                                            OwaspCategory::AuthenticationFailures.reference_url(),
                                        ],
                                        metadata: {
                                            let mut meta = HashMap::new();
                                            meta.insert("vulnerability_type".to_string(), "trust_auth".to_string());
                                            meta.insert("service".to_string(), "postgresql".to_string());
                                            meta.insert("severity_reason".to_string(), "No authentication required".to_string());
                                            meta
                                        },
                                    });
                                }
                                3 => {
                                    // Cleartext password
                                    return Some(Finding {
                                        title: "PostgreSQL Cleartext Password Authentication".to_string(),
                                        description: "PostgreSQL is accepting cleartext passwords which can be intercepted".to_string(),
                                        severity: Severity::High,
                                        confidence: 0.9,
                                        evidence: vec![
                                            "PostgreSQL using cleartext password authentication".to_string(),
                                        ],
                                        recommendations: vec![
                                            "Use scram-sha-256 authentication method".to_string(),
                                            "Enable SSL/TLS for all connections".to_string(),
                                        ],
                                        references: vec![
                                            "https://www.postgresql.org/docs/current/auth-password.html".to_string(),
                                        ],
                                        metadata: {
                                            let mut meta = HashMap::new();
                                            meta.insert("vulnerability_type".to_string(), "cleartext_auth".to_string());
                                            meta.insert("service".to_string(), "postgresql".to_string());
                                            meta
                                        },
                                    });
                                }
                                _ => {}
                            }
                        }
                    }
                }
            }
            _ => {}
        }
        None
    }
}

impl FindingBuilder for WeakAuthScanner {}

#[async_trait]
impl Plugin for WeakAuthScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Scans for weak authentication mechanisms in database services"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::High
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        _scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        // Check MySQL authentication
        if port == 3306 || port == 3307 {
            if let Some(finding) = self.check_mysql_auth(target, port).await {
                findings.push(finding);
            }
        }

        // Check PostgreSQL authentication
        if port == 5432 || port == 5433 {
            if let Some(finding) = self.check_postgres_auth(target, port).await {
                findings.push(finding);
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for WeakAuthScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        let db_services = vec!["mysql", "postgresql", "mssql", "oracle", "mongodb"];
        db_services
            .iter()
            .any(|s| service_name.to_lowercase().contains(s))
            || vec![3306, 3307, 5432, 5433, 1433, 1521, 27017].contains(&port)
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "authentication".to_string(),
            "weak_auth".to_string(),
            "database".to_string(),
        ]
    }
}

/// Default Credentials Scanner
pub struct DefaultCredsScanner {
    name: String,
    version: String,
    default_creds: HashMap<String, Vec<(&'static str, &'static str)>>,
}

impl DefaultCredsScanner {
    pub fn new() -> Self {
        let mut default_creds = HashMap::new();

        // MySQL default credentials
        default_creds.insert(
            "mysql".to_string(),
            vec![
                ("root", ""),
                ("root", "root"),
                ("root", "password"),
                ("root", "mysql"),
                ("mysql", "mysql"),
                ("admin", "admin"),
            ],
        );

        // PostgreSQL default credentials
        default_creds.insert(
            "postgresql".to_string(),
            vec![
                ("postgres", "postgres"),
                ("postgres", "password"),
                ("postgres", ""),
                ("admin", "admin"),
            ],
        );

        // MSSQL default credentials
        default_creds.insert(
            "mssql".to_string(),
            vec![
                ("sa", ""),
                ("sa", "sa"),
                ("sa", "password"),
                ("sa", "Password123"),
                ("admin", "admin"),
            ],
        );

        // MongoDB default credentials
        default_creds.insert(
            "mongodb".to_string(),
            vec![
                ("admin", "admin"),
                ("root", "root"),
                ("", ""), // No auth
            ],
        );

        // Redis (usually no auth by default)
        default_creds.insert(
            "redis".to_string(),
            vec![
                ("", ""), // No auth
                ("default", "redis"),
            ],
        );

        Self {
            name: "Default Credentials Scanner".to_string(),
            version: "1.0.0".to_string(),
            default_creds,
        }
    }

    fn get_service_from_port(&self, port: u16) -> Option<&str> {
        match port {
            3306 | 3307 => Some("mysql"),
            5432 | 5433 => Some("postgresql"),
            1433 | 1434 => Some("mssql"),
            27017 => Some("mongodb"),
            6379 => Some("redis"),
            _ => None,
        }
    }
}

impl FindingBuilder for DefaultCredsScanner {}

#[async_trait]
impl Plugin for DefaultCredsScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Checks for default credentials in database services"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::Critical
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
    }

    async fn analyze(
        &self,
        target: IpAddr,
        port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = std::time::Instant::now();
        let mut findings = Vec::new();

        // Determine service type from port or banner
        let service = if let Some(service_name) = &scan_result.service {
            service_name.to_lowercase()
        } else if let Some(service) = self.get_service_from_port(port) {
            service.to_string()
        } else {
            return PluginResult {
                plugin_name: self.name().to_string(),
                target_ip: target,
                target_port: port,
                execution_time: start_time.elapsed(),
                success: false,
                error_message: Some("Could not determine database service type".to_string()),
                findings,
                raw_data: None,
            };
        };

        // Create a warning about potential default credentials
        for (db_type, creds) in &self.default_creds {
            if service.contains(db_type) {
                let finding = Finding {
                    title: format!(
                        "Potential Default Credentials on {}",
                        db_type.to_uppercase()
                    ),
                    description: format!(
                        "The {} service on port {} should be checked for default credentials. Common default username/password combinations exist for this service.",
                        db_type, port
                    ),
                    severity: Severity::High,
                    confidence: 0.5, // Lower confidence since we're not actively testing
                    evidence: vec![
                        format!("Service identified as: {}", service),
                        format!(
                            "Common default accounts to check: {}",
                            creds
                                .iter()
                                .map(|(u, _)| if u.is_empty() { "(no auth)" } else { u })
                                .collect::<Vec<_>>()
                                .join(", ")
                        ),
                    ],
                    recommendations: vec![
                        "Change all default passwords immediately".to_string(),
                        "Disable or rename default accounts".to_string(),
                        "Implement strong password policies".to_string(),
                        "Use certificate-based authentication where possible".to_string(),
                        format!("Review {} security best practices", db_type),
                    ],
                    references: vec![
                        OwaspCategory::AuthenticationFailures.reference_url(),
                        "https://cwe.mitre.org/data/definitions/798.html".to_string(),
                    ],
                    metadata: {
                        let mut meta = HashMap::new();
                        meta.insert(
                            "vulnerability_type".to_string(),
                            "default_credentials".to_string(),
                        );
                        meta.insert("service".to_string(), db_type.clone());
                        meta.insert("requires_testing".to_string(), "true".to_string());
                        meta
                    },
                };
                findings.push(finding);
                break;
            }
        }

        PluginResult {
            plugin_name: self.name().to_string(),
            target_ip: target,
            target_port: port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }
}

#[async_trait]
impl VulnerabilityScanner for DefaultCredsScanner {
    fn applies_to_service(&self, service_name: &str, port: u16) -> bool {
        self.default_creds
            .keys()
            .any(|s| service_name.to_lowercase().contains(s))
            || self.get_service_from_port(port).is_some()
    }

    fn vulnerability_categories(&self) -> Vec<String> {
        vec![
            "authentication".to_string(),
            "default_credentials".to_string(),
            "database".to_string(),
        ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sql_injection_patterns() {
        let scanner = SqlInjectionScanner::new();
        assert!(!scanner.error_patterns.is_empty());
    }

    #[test]
    fn test_default_creds_service_detection() {
        let scanner = DefaultCredsScanner::new();
        assert_eq!(scanner.get_service_from_port(3306), Some("mysql"));
        assert_eq!(scanner.get_service_from_port(5432), Some("postgresql"));
        assert_eq!(scanner.get_service_from_port(1433), Some("mssql"));
        assert_eq!(scanner.get_service_from_port(80), None);
    }

    #[tokio::test]
    async fn test_weak_auth_scanner_creation() {
        let scanner = WeakAuthScanner::new();
        assert_eq!(scanner.name(), "Database Weak Authentication Scanner");
    }
}
