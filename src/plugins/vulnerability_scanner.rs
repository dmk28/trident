use crate::os_fingerprint::banner_grabber::{grab_ftp_banner, grab_http_banner, grab_ssh_banner};
use crate::plugins::plugin_trait::{
    Finding, Plugin, PluginConfig, PluginPriority, PluginResult, Severity,
};
use crate::scanner::structure::{PortStatus, ScanResult};
use crate::vulndb::{VulnCheckType, VulnerabilityDatabase, VulnerabilityRule};
use async_trait::async_trait;
use std::collections::HashMap;
use std::net::IpAddr;
use std::time::Instant;
use tokio::net::TcpStream;
use tokio::time::{Duration, timeout};

pub struct VulnerabilityPlugin {
    pub name: String,
    pub version: String,
    vulnerability_db: VulnerabilityDatabase,
}

impl VulnerabilityPlugin {
    pub fn new() -> Self {
        Self {
            name: "VulnerabilityScanner".to_string(),
            version: "2.0.0".to_string(),
            vulnerability_db: VulnerabilityDatabase::new(),
        }
    }

    pub async fn new_with_github_data() -> Result<Self, Box<dyn std::error::Error>> {
        let mut plugin = Self::new();
        plugin
            .vulnerability_db
            .cve_db
            .initialize_with_github_data()
            .await?;
        Ok(plugin)
    }

    async fn check_service_vulnerabilities(
        &self,
        ip: IpAddr,
        port: u16,
        service_name: Option<&str>,
        banner: Option<&str>,
        config: &PluginConfig,
    ) -> Vec<Finding> {
        let mut findings = Vec::new();

        // First, check service-specific vulnerabilities (requires service detection)
        if let Some(service) = service_name {
            let service_vulns = self
                .vulnerability_db
                .find_vulnerabilities_for_service(service, banner);

            for rule in service_vulns {
                // Only flag if we have actual service evidence
                let evidence = vec![
                    format!("Service: {} on port {}", service, port),
                    banner
                        .map(|b| format!("Banner: {}", b))
                        .unwrap_or_else(|| "Service detected via fingerprinting".to_string()),
                ];
                findings.push(
                    self.vulnerability_db
                        .create_finding_from_rule(rule, evidence),
                );
            }

            // Check for CVEs using the enhanced database
            let version = banner.and_then(|b| self.extract_version_from_banner(service, b));
            let cves = self.vulnerability_db.find_cves_for_service(
                service,
                version.as_deref(),
                None, // CPE not yet extracted
                config.min_cvss,
            );
            findings.extend(cves);
        }

        // Then check vulnerabilities that require specific evidence
        let port_vulns = self.vulnerability_db.find_vulnerabilities_for_port(port);

        for rule in port_vulns {
            // Skip if this rule requires service-specific evidence and we don't have it
            if self.requires_service_evidence(rule) && service_name.is_none() {
                continue;
            }

            match &rule.check_type {
                VulnCheckType::OpenPort => {
                    // Only flag generic port-based vulnerabilities for certain categories
                    if self.is_generic_port_vulnerability(rule) {
                        let evidence = vec![format!("Port {} is open", port)];
                        findings.push(
                            self.vulnerability_db
                                .create_finding_from_rule(rule, evidence),
                        );
                    }
                }
                VulnCheckType::BannerMatch(pattern) => {
                    if let Some(banner_text) = banner {
                        if banner_text.to_lowercase().contains(&pattern.to_lowercase()) {
                            let evidence = vec![
                                format!("Port {}: {}", port, banner_text),
                                format!("Matched pattern: {}", pattern),
                            ];
                            findings.push(
                                self.vulnerability_db
                                    .create_finding_from_rule(rule, evidence),
                            );
                        }
                    }
                }
                VulnCheckType::VersionCheck {
                    service,
                    pattern: _,
                } => {
                    if let Some(detected_service) = service_name {
                        if detected_service
                            .to_lowercase()
                            .contains(&service.to_lowercase())
                        {
                            let evidence = vec![
                                format!("Service detected: {}", detected_service),
                                format!("Port: {}", port),
                            ];
                            findings.push(
                                self.vulnerability_db
                                    .create_finding_from_rule(rule, evidence),
                            );
                        }
                    }
                }
                VulnCheckType::CustomScript(script_name) => {
                    if let Some(custom_finding) =
                        self.run_custom_check(ip, port, script_name, banner).await
                    {
                        findings.push(custom_finding);
                    }
                }
            }
        }

        findings
    }

    fn requires_service_evidence(&self, rule: &VulnerabilityRule) -> bool {
        // Critical CVEs like Log4Shell require actual service evidence
        rule.cve_ids.iter().any(|cve| {
            matches!(
                cve.as_str(),
                "CVE-2021-44228" | "CVE-2021-45046" | "CVE-2022-22963" | "CVE-2022-0543"
            )
        }) || rule.category == "rce"
    }

    fn is_generic_port_vulnerability(&self, rule: &VulnerabilityRule) -> bool {
        // Allow generic warnings for these categories
        matches!(rule.category.as_str(), "plaintext" | "auth" | "database")
    }

    async fn run_custom_check(
        &self,
        ip: IpAddr,
        port: u16,
        script_name: &str,
        _banner: Option<&str>,
    ) -> Option<Finding> {
        match script_name {
            "redis_unauth" => self.check_redis_unauthorized_access(ip, port).await,
            "mysql_root_remote" => self.check_mysql_root_access(ip, port).await,
            "postgres_weak_auth" => self.check_postgres_weak_auth(ip, port).await,
            "ftp_anonymous" => self.check_ftp_anonymous_login(ip, port).await,
            "snmp_default_community" => self.check_snmp_default_community(ip, port).await,
            _ => None,
        }
    }

    async fn check_redis_unauthorized_access(&self, ip: IpAddr, port: u16) -> Option<Finding> {
        let connect_result = timeout(Duration::from_secs(5), TcpStream::connect((ip, port))).await;

        if let Ok(Ok(mut stream)) = connect_result {
            use tokio::io::{AsyncReadExt, AsyncWriteExt};

            // Try to send INFO command
            if stream.write_all(b"INFO\r\n").await.is_ok() {
                let mut buffer = [0; 1024];
                if let Ok(bytes_read) = stream.read(&mut buffer).await {
                    if bytes_read > 0 {
                        let response = String::from_utf8_lossy(&buffer[..bytes_read]);
                        if response.contains("redis_version") {
                            return Some(Finding {
                                title: "Redis Unauthorized Access".to_string(),
                                description: "Redis server allows unauthenticated access. This can lead to data exposure and potential remote code execution.".to_string(),
                                severity: Severity::Critical,
                                confidence: 0.95,
                                evidence: vec![
                                    format!("Successfully connected to Redis on {}:{}", ip, port),
                                    format!("Server response: {}", response.lines().next().unwrap_or("")),
                                ],
                                recommendations: vec![
                                    "Configure Redis authentication with requirepass".to_string(),
                                    "Bind Redis to localhost only if external access not needed".to_string(),
                                    "Use firewall rules to restrict access".to_string(),
                                ],
                                references: vec![
                                    "https://redis.io/topics/security".to_string(),
                                    "https://nvd.nist.gov/vuln/detail/CVE-2022-0543".to_string(),
                                ],
                                metadata: {
                                    let mut m = HashMap::new();
                                    m.insert("cve_ids".to_string(), "CVE-2022-0543".to_string());
                                    m
                                },
                            });
                        }
                    }
                }
            }
        }
        None
    }

    async fn check_mysql_root_access(&self, ip: IpAddr, port: u16) -> Option<Finding> {
        // This is a simplified check - in practice you'd use a MySQL client library
        let connect_result = timeout(Duration::from_secs(5), TcpStream::connect((ip, port))).await;

        if let Ok(Ok(_stream)) = connect_result {
            // For now, just report that MySQL is accessible
            // TODO: Implement actual MySQL protocol handshake and authentication test
            return Some(Finding {
                title: "MySQL Database Exposed".to_string(),
                description: "MySQL database server is accessible from external networks. This could indicate weak access controls.".to_string(),
                severity: Severity::High,
                confidence: 0.7,
                evidence: vec![
                    format!("MySQL server accessible on {}:{}", ip, port),
                ],
                recommendations: vec![
                    "Review MySQL user privileges and remote access settings".to_string(),
                    "Implement network-level access controls".to_string(),
                    "Ensure strong authentication is configured".to_string(),
                ],
                references: vec![
                    "https://dev.mysql.com/doc/refman/8.0/en/access-control.html".to_string(),
                ],
                metadata: HashMap::new(),
            });
        }
        None
    }

    async fn check_postgres_weak_auth(&self, ip: IpAddr, port: u16) -> Option<Finding> {
        let connect_result = timeout(Duration::from_secs(5), TcpStream::connect((ip, port))).await;

        if let Ok(Ok(_stream)) = connect_result {
            return Some(Finding {
                title: "PostgreSQL Database Exposed".to_string(),
                description: "PostgreSQL database server is accessible from external networks."
                    .to_string(),
                severity: Severity::Medium,
                confidence: 0.6,
                evidence: vec![format!("PostgreSQL server accessible on {}:{}", ip, port)],
                recommendations: vec![
                    "Review pg_hba.conf for proper access controls".to_string(),
                    "Use strong authentication methods".to_string(),
                    "Implement SSL/TLS encryption".to_string(),
                ],
                references: vec![
                    "https://www.postgresql.org/docs/current/auth-pg-hba-conf.html".to_string(),
                ],
                metadata: HashMap::new(),
            });
        }
        None
    }

    async fn check_ftp_anonymous_login(&self, ip: IpAddr, port: u16) -> Option<Finding> {
        let connect_result = timeout(Duration::from_secs(5), TcpStream::connect((ip, port))).await;

        if let Ok(Ok(stream)) = connect_result {
            use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};

            let (reader, mut writer) = stream.into_split();
            let mut reader = BufReader::new(reader);
            let mut response = String::new();

            // Read FTP welcome message
            if reader.read_line(&mut response).await.is_ok() {
                if response.contains("220") {
                    // Try anonymous login
                    if writer.write_all(b"USER anonymous\r\n").await.is_ok() {
                        response.clear();
                        if reader.read_line(&mut response).await.is_ok() && response.contains("331")
                        {
                            if writer.write_all(b"PASS anonymous@\r\n").await.is_ok() {
                                response.clear();
                                if reader.read_line(&mut response).await.is_ok()
                                    && response.contains("230")
                                {
                                    return Some(Finding {
                                        title: "FTP Anonymous Access Enabled".to_string(),
                                        description: "FTP server allows anonymous login, potentially exposing sensitive files and directories.".to_string(),
                                        severity: Severity::Medium,
                                        confidence: 0.9,
                                        evidence: vec![
                                            format!("Anonymous FTP login successful on {}:{}", ip, port),
                                            format!("Server response: {}", response.trim()),
                                        ],
                                        recommendations: vec![
                                            "Disable anonymous FTP access".to_string(),
                                            "Use SFTP instead of FTP".to_string(),
                                            "Implement proper authentication".to_string(),
                                        ],
                                        references: vec![
                                            "https://owasp.org/www-community/vulnerabilities/Insecure_Transport".to_string(),
                                        ],
                                        metadata: HashMap::new(),
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }
        None
    }

    async fn check_snmp_default_community(&self, ip: IpAddr, port: u16) -> Option<Finding> {
        // This is a simplified check - SNMP uses UDP, not TCP
        // For now, just report that SNMP is potentially accessible
        if port == 161 || port == 162 {
            return Some(Finding {
                title: "SNMP Service Detected".to_string(),
                description: "SNMP service detected. If using default community strings (public/private), sensitive system information may be exposed.".to_string(),
                severity: Severity::Medium,
                confidence: 0.5,
                evidence: vec![
                    format!("SNMP service likely running on {}:{}", ip, port),
                ],
                recommendations: vec![
                    "Change default SNMP community strings".to_string(),
                    "Use SNMPv3 with authentication and encryption".to_string(),
                    "Restrict SNMP access with ACLs".to_string(),
                ],
                references: vec![
                    "https://owasp.org/www-project-top-ten/2021/A07_2021-Identification_and_Authentication_Failures/".to_string(),
                ],
                metadata: HashMap::new(),
            });
        }
        None
    }
}

#[async_trait]
impl Plugin for VulnerabilityPlugin {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn description(&self) -> &str {
        "Advanced vulnerability scanner with CVE database integration"
    }

    fn priority(&self) -> PluginPriority {
        PluginPriority::Medium // Run after service detection
    }

    fn can_analyze(&self, scan_result: &ScanResult) -> bool {
        matches!(scan_result.status, PortStatus::Open)
    }

    fn required_port_status(&self) -> Vec<PortStatus> {
        vec![PortStatus::Open]
    }

    async fn analyze(
        &self,
        target_ip: IpAddr,
        target_port: u16,
        scan_result: &ScanResult,
        _config: &PluginConfig,
    ) -> PluginResult {
        let start_time = Instant::now();
        println!(
            "🚨 Scanning {}:{} for vulnerabilities...",
            target_ip, target_port
        );

        let mut findings = Vec::new();

        // Perform actual service fingerprinting
        let (service_name, banner) = self.fingerprint_service(target_ip, target_port).await;

        // Only proceed with vulnerability checks if we actually identified a service
        if service_name.is_none() && banner.is_none() {
            println!(
                "⚠️  Could not fingerprint service on {}:{} - skipping vulnerability assessment",
                target_ip, target_port
            );
            return PluginResult {
                plugin_name: self.name.clone(),
                target_ip,
                target_port,
                execution_time: start_time.elapsed(),
                success: true,
                error_message: None,
                findings: vec![],
                raw_data: None,
            };
        }

        // Check for known vulnerabilities with actual service evidence
        let vulns = self
            .check_service_vulnerabilities(
                target_ip,
                target_port,
                service_name.as_deref(),
                banner.as_deref(),
                _config,
            )
            .await;

        findings.extend(vulns);

        // Only flag critical vulnerabilities if we have service evidence
        if let Some(service) = &service_name {
            let critical_vulns = self.vulnerability_db.get_critical_vulnerabilities();
            for critical in critical_vulns {
                if critical.ports.contains(&target_port)
                    && self.service_matches_vulnerability(service, &banner, critical)
                {
                    let evidence = vec![
                        format!("Service identified: {} on port {}", service, target_port),
                        banner
                            .as_ref()
                            .map(|b| format!("Banner: {}", b))
                            .unwrap_or_else(|| "Service detected via fingerprinting".to_string()),
                        format!("Matching CVE IDs: {:?}", critical.cve_ids),
                    ];
                    findings.push(
                        self.vulnerability_db
                            .create_finding_from_rule(critical, evidence),
                    );
                }
            }
        }

        PluginResult {
            plugin_name: self.name.clone(),
            target_ip,
            target_port,
            execution_time: start_time.elapsed(),
            success: true,
            error_message: None,
            findings,
            raw_data: None,
        }
    }

    async fn initialize(&mut self) -> Result<(), String> {
        println!("🔧 Initializing Enhanced Vulnerability Scanner with GitHub CVE integration...");

        // Enhanced CVE database initialization
        match self.enhanced_cve_initialization().await {
            Ok(_) => {
                println!("✅ Enhanced CVE database initialization complete");
            }
            Err(e) => {
                println!(
                    "⚠️  Enhanced initialization failed: {}. Using basic database.",
                    e
                );
                // Fallback to basic CVE loading
                if let Err(basic_err) = self.vulnerability_db.cve_db.update_with_latest_cves().await
                {
                    println!(
                        "⚠️  Basic CVE loading also failed: {}. Using minimal database.",
                        basic_err
                    );
                }
            }
        }

        println!(
            "📚 Loaded {} vulnerability rules",
            self.vulnerability_db.rules.len()
        );
        println!(
            "🎯 {} CVE entries available",
            self.vulnerability_db.cve_db.cves.len()
        );
        println!(
            "🔴 {} critical vulnerabilities in database",
            self.vulnerability_db.get_critical_vulnerabilities().len()
        );
        Ok(())
    }
}

impl VulnerabilityPlugin {
    async fn enhanced_cve_initialization(&mut self) -> Result<(), String> {
        println!("🌐 Fetching CVEs from GitHub CVE database...");

        // Process recent high-impact CVEs (last 5 years)
        let current_year = 2024;
        let start_year = current_year - 5;

        match self
            .vulnerability_db
            .cve_db
            .batch_process_github_cves(start_year..current_year, Some(Severity::Critical))
            .await
        {
            Ok(_) => {
                println!("✅ Successfully processed critical CVEs from GitHub");
            }
            Err(e) => {
                println!("⚠️  GitHub CVE processing failed: {}", e);
                return Err(format!("CVE processing failed: {}", e));
            }
        }

        // Update service-to-CVE mappings based on fetched data
        self.vulnerability_db
            .cve_db
            .update_service_cve_mappings()
            .await
            .map_err(|e| e.to_string())?;

        Ok(())
    }
    async fn fingerprint_service(&self, ip: IpAddr, port: u16) -> (Option<String>, Option<String>) {
        match port {
            22 => {
                // SSH fingerprinting
                if let Ok(banner) = grab_ssh_banner(ip, port).await {
                    return (Some("ssh".to_string()), Some(banner));
                }
            }
            21 => {
                // FTP fingerprinting
                if let Ok(banner) = grab_ftp_banner(ip, port).await {
                    return (Some("ftp".to_string()), Some(banner));
                }
            }
            80 | 443 | 8080 | 8443 => {
                // HTTP/HTTPS fingerprinting
                if let Ok(banner) = grab_http_banner(ip, port, None).await {
                    // Analyze the HTTP banner to determine actual service
                    let service = self.analyze_http_service(&banner);
                    return (Some(service), Some(banner));
                }
            }
            _ => {
                // Generic TCP banner grab for other services
                if let Some(banner) = self.generic_banner_grab(ip, port).await {
                    let service = self.guess_service_from_banner(&banner, port);
                    return (service, Some(banner));
                }
            }
        }

        // No service identified
        (None, None)
    }

    fn extract_version_from_banner(&self, service: &str, banner: &str) -> Option<String> {
        // Simple version extraction - can be enhanced
        if service.contains("ssh") {
            if banner.contains("OpenSSH") {
                let parts: Vec<&str> = banner.split_whitespace().collect();
                for part in parts {
                    if part.contains("OpenSSH") {
                        return Some(part.replace("OpenSSH_", "").replace("OpenSSH/", ""));
                    }
                }
            }
        }
        None
    }

    fn analyze_http_service(&self, banner: &str) -> String {
        let banner_lower = banner.to_lowercase();

        if banner_lower.contains("apache") {
            "apache".to_string()
        } else if banner_lower.contains("nginx") {
            "nginx".to_string()
        } else if banner_lower.contains("iis") {
            "iis".to_string()
        } else if banner_lower.contains("tomcat") {
            "tomcat".to_string()
        } else if banner_lower.contains("jetty") {
            "jetty".to_string()
        } else {
            "http".to_string()
        }
    }

    async fn generic_banner_grab(&self, ip: IpAddr, port: u16) -> Option<String> {
        let connect_result = timeout(Duration::from_secs(3), TcpStream::connect((ip, port))).await;

        if let Ok(Ok(stream)) = connect_result {
            use tokio::io::{AsyncReadExt, AsyncWriteExt};
            let mut buffer = [0; 1024];

            // Try to read initial banner
            if let Ok(bytes_read) = timeout(Duration::from_secs(2), stream.readable()).await {
                if bytes_read.is_ok() {
                    if let Ok(n) = stream.try_read(&mut buffer) {
                        if n > 0 {
                            return Some(String::from_utf8_lossy(&buffer[..n]).to_string());
                        }
                    }
                }
            }
        }

        None
    }

    fn guess_service_from_banner(&self, banner: &str, port: u16) -> Option<String> {
        let banner_lower = banner.to_lowercase();

        // Check for specific service signatures
        if banner_lower.contains("mysql") {
            Some("mysql".to_string())
        } else if banner_lower.contains("postgresql") {
            Some("postgresql".to_string())
        } else if banner_lower.contains("redis") {
            Some("redis".to_string())
        } else if banner_lower.contains("ssh-") {
            Some("ssh".to_string())
        } else if banner_lower.contains("220") && port == 21 {
            Some("ftp".to_string())
        } else if banner_lower.contains("smtp") || (banner_lower.contains("220") && port == 25) {
            Some("smtp".to_string())
        } else {
            None
        }
    }

    fn service_matches_vulnerability(
        &self,
        service: &str,
        banner: &Option<String>,
        rule: &VulnerabilityRule,
    ) -> bool {
        // Check if the identified service matches the vulnerability rule
        let service_lower = service.to_lowercase();

        for pattern in &rule.service_patterns {
            if service_lower.contains(&pattern.to_lowercase()) {
                return true;
            }
        }

        // Check banner content for additional matches
        if let Some(banner_text) = banner {
            let banner_lower = banner_text.to_lowercase();
            for pattern in &rule.service_patterns {
                if banner_lower.contains(&pattern.to_lowercase()) {
                    return true;
                }
            }
        }

        false
    }
}
